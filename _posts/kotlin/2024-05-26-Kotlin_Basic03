---
layout: post
title: Kotlin. 
summary: Kotlin Study
author: devhtak
date: '2024-05-26 21:41:00 +0900'
category: Kotlin Study
---

#### 제네릭과 배열
- 제네릭
  ```kotlin
  class Box<T>(var name: T)
  ```
  - 클래스 내부에서 사용할 자료형을 나중에 인스턴스를 생성할 때 확정한다. 
  - 객체의 자료형을 컴파일할 때 체크하기 때문에 객체 자료형의 안정성을 높이고 형 변환의 번거러움을 줄일 수 있다.
  - 제네릭으로 선언된 변수를 프로퍼티를 사용하는 경우 생성자를 통해 초기값을 지정하며, 형식 매개변수는 기본적으로 null을 허용한 형태로 선언된다
    ```kotlin
    fun <T> find(a: Array<T>, target: T): Int {
        for(i in a.indices) {
            if(a[i] == target) return i
        }
        return -1
    }
    ```
  - 람다식을 매개변수로 받으면 자료형을 결정하지 않아도 실행 시 람다식 본문을 넘겨줄 때 결정되어 오류를 해결할 수 있다.
    ```kotlin
    fun <T> add(a: T, b: T, op: (T, T) -> T) = op(a, b)

    fun main() {
        println(add(10, 20) { a, b -> a+b}) // 30
    }
    ```
  - 콜론(:)을 사용하여 매개변수를 받은 특정한 자료형으로 제한할 수 있다.
    ```kotlin
    class Car<T: Number> {
        fun plus(arg1: T, arg2: T): Double= arg1.toDouble() arg2.toDouble()
    }
    fun <T: Number> addNumber(a: T, b: T, op: (T, T) -> T): T = op(a, b)
    ```
  - 상하위 형식의 가변성
    - 가변성이란 형식 매개변수가 클래스 계층에 영향을 주는 것을 만든다.
      - 예를 들어, 형식 A의 값이 필요한 모든 클래스에 B의 값을 넣어도 아무 문제 없다면 B는 A의 하위 형식이 된다.
    - Any <- Int <- Notiing
    - 무변성: 자료형 사이의 하위 관계가 성립되지 않는다.
      - 코틀린에서는 따로 지정해주지 않으면 기본적으로 무변성이다.
      ```kotlin
      class Box<T>(val size: Int)
      fun main() {
          val anys1: Box<Any> = Box<Int>(10) // 오류 / 자료 불일치
          val anys2: Box<Noting> = Box<Int>(10) // 오류 / 자료 불일치
      }
      ```
    - 공변성(out keyword): 형식 매개변수 사이의 하위 자료형 관계가 성립하고, 그 관계가 인스턴스 자료형 관계로 이어진다.
    - 반공변성(in keyword): 공변성과 반대 개념
      ```kotlin
      class BoxOut<out T>(val size: Int)
      class BoxIn<in T>(val size: Int)
      fun main() {
          val anyOut: Box<Any> = Box<Int>(10) // 공변성
          var anyIn: Box<Noting> = Box<int>(20) // 반공변성
      }
    - 가변성의 두가지 방법
      ```kotlin
      class Box<in T:Animal>(var item: T)
      ```
      - 선언 지점 변성(Declaration-Site Variance): 클래스 자체에 가변성을 지정하는 방식이다.
      ```kotlin
      class Box<T>(var item: T)
      fun <T> printBox(box: Box<out Animal>) {
          val object: Animal = box.item
          println(object);
      }
      - 사용 지점 변성(Use-Site Variance): 메서드의 매개변수나 제네릭 클래스를 생성할 때와 같이 사용 위치에서 가변성을 지정하는 방식이다.
    - 자료형 프로젝션(Type Projection): 사용하고자 하는 요소의 특정 자료형에 in 또는 out을 지정해 제한하는 것을 말한다. 자료형 프로젝션을 통해 자료의 안정성을 보장한다.
    - 스타 프로젝션(Star Projection): 어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되면 그 자료형과 하위 자료형의 요소만 허용한다.
      - in으로 정의된 형식 매개변수를 *로 받으면 in Nothing으로 간주
      - out으로 정의된 형식 매개변수를 *로 받으면 out Any?으로 간주
    - refied 자료형
      ```kotlin
      fun main() {
          println(getType<Float>(10)); // 10
      }
      inner fun <reified T> getType(value: Int>:T {
          return when(T::class) {
              Float::class -> value.toFloat() as T
              Int::class -> value ad T
              else -> throw IllegalStateException()
          }
      }
      ```
      - inline 함수에서 형식 매개변수를 실행 시간에 직접 접근하기 위해 사용      
- 배열
  - kotlin은 배열을 여러 가지 자료형을 혼합하여 구성할 수 있으며 다차원 배열 선언도 가능하다 
    ```kotlin
    val numbers = arrayOf(6, 8, "Kim", "Lee")
    var arr2D = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6), arrayOf(7, 8, 9))

    val evenArray = Array<Int>(5) {it * 2} // [0, 2, 4, 6, 8] 
    val array1 = arrayOfNulls<Int>(100) // 100개의 null로 채워진 정수 배열
    val array2 = Array<Int>(1000) {0} // 1000개의 0으로 채워진 정수 배열
    ```
  - 배열 접근은 get, set 또는 \[index] 로 가능하다
    ```kotlin
    public class Array<T> {
        public inline constructor(size: Int, init: (Int) -> T)
        public operator fun get(index: Int): T
        public operator fun set(index: Int, value: T): Unit
        public operator fun size(): Int
        public operator fun iterator(): Iterator<T>
    }
    array.get(index)
    array.set(index, value)
    value = array[index]
    array[index] = value
    ```
  - 다양한 방법의 배열 다루기
    - 배열에 요초 추가 및 잘라내기
      ```kotlin
      var arr1 = arrayOf<Int>(1, 2, 3)
      var arr2 = arr1.plus(4) // 1, 2, 3, 4
      var arr3 = arr1.sliceArray(1..2) // 2, 3
      ```
    - 배열 순환
      ```kotlin
      var arr1 = arrayOf<Int>(1, 2, 3)
      arr1.forEach {e -> println("$e"}
      arr1.forEachIndexed {i, e -> println("array[$i]: $e")}
      var iter: Iterator<Int> = array.iterator()
      while(iter.hasNext()) {
          val e = iter.next()
          println("$e")
      }
      ```
    - 오름차순 정렬
      - 일반 배열로 반환: sortedArray(), 원본배열정렬: sort()
    - 내림차순 정렬
      - 일반 배열로 반환: sortedArrayDescending(), 원본 배열 정렬: sortDescending()
    - sortBy를 이용한 특정 표현식 사용
      items.sortBy { item -> item.length }
    - 배열 필터링
      - filter {it > 0}
    - 배열 평탄화
      - flatten() // 1차원 배열
- 문자열 다루기
  - 문자열은 불변(immutable) 값으로 생성되기 때문에 참조되고 있는 메모리가 변경될 수 없다. 더 이상 참조되지 않는 문자열은 GC(Garbage Collector)에 의해 제거된다.
  - 문자열 추출
    - String.substring(index_범위): String
    - CharSequence.subSequence(index_범위): CharSequence
  - 문자열 비교
    - stringA.compareTo(stringB) // A==B: 0, A<B: 음수, A<B양수
    
#### Collection
- 컬렉션 종류
  - List: listOf(불변), mutableListOf/arrayListOf(가변)
  - Set: setOf(불변), mutableSetOf/hashSetOf/linkedSetOf/sortedSetOf(가변형)
  - Map: mapOf(불변), mutableMapOf/hashMapOf/linkedMapOf/sortedMapOf(가변형
- Collection 인스턴스 멤버
  - isEmpty()
  - contains(element:E)
  - containsAll(element:Collection<E>)
- MutableCollection 인스턴스 메서드
  - add(element:E)
  - remove(element:E)
  - addAll(elements:Collection<E>)
  - removeAll(elements:Collection<E>)
  - retainAll(elements:Collection<E>)
  - clear()
- List 활용하기
  - 불변형 List
    - 불변형 List 생성 핼퍼 함수
      - listOf(): 가변 인자를 받아 원하는 만큼 요소를 지정할 수 있다. List<T>를 반환하며 형식 매개변수를 지정하지 않으면 기본값인 <Any>를 사용한다.
      - emptyList(): 비어있는 List를 생성하기 위해 사용한다. 이때 반드시 형식 매개변수를 지정한다.
      - listOfNotNull(): null을 제외한 요소만 List로 구성한다.
    - List의 주요 멤버 메서드
      - get(index: Int)
      - indexOf(element: E)
      - lastIndexOf(element: E)
      - listIterator()
      - subList(fromIndex: Int, toIndex: Int)
  - 가변형 List
    - 가변형 List 생성 핼퍼 함수
      - arrayListOf(): 가변형 List를 생성하지만 반환 자료형은 자바의 ArrayList다
      - mutableListOf(): 코틀린의 MutableList 인터페이스를 사용하는 헬퍼 함수다.
- Set 활용하기
  - 불변형 Set
    - setOf(): 불변형 Set인 Set<T> 자료형을 반환한다.
  - 가변형 Set
    - mutableSetOf(): 가변형 Set인 MutableSet<T> 자료형을 반환하지만, 내부적으로자바의 LinkedHashSet을 생성한다.
    - hashSetOf(): 해시 테이블에 요소를 자장할 수 있는 자바의 HashSet 컬렉션을 생성한다. 요소의 추가와 삭제가 가능하며 O(1) 시간복잡도의 검색 속도를 갖는다.
    - sortedSetOf(): 자바의 TreeSet 컬렉션을 정렬된 상태로 반환한다. HashSet보다 성능이 조금 떨어지지만 검색과 정렬이 뛰아나다는 장점이 있다.
    - linkedSetOf(): 자바의 LinkedHashSet 자료형을 반환한다. 링크드 리스트(Linked List) 자료구조를 사용해 구현된 해시 테이블에 요소를 저장한다.
- Map 활용하기
  - 생성 헬퍼 함수
    - mapOf():	불변형 Map 컬렉션을 만들 수 있다.
    - mutableMapOf(): 추가, 삭제가 가능한 가변형 Map을 정의한다.
    - hashMapOf(): 해시 테이블에 요소를 자장할 수 있는 자바의 HashMap 컬렉션을 생성한다.
    - sortedMapOf(): 자바의 TreeMap 컬렉션을 정렬된 상태로 반환한다.
    - linkedMapOf(): 자바의 LinkedHashMap 자료형을 반환한다.
  - 불변형 Map 프로퍼티와 메소드
    - size: Map 컬렉션의 크기를 반환한다.
    - keys: Map의 모든 키를 반환한다.
    - values: Map의 모든 값을 반환한다.
    - isEmpty(): Map이 비어 있는지 확인한다. 비어있으면 true, 아니면 false를 반환한다.
    - containsKey(key: K): 인자에 해당하는 키가 있으면 true, 아니면 false를 반환한다.
    - containsValue(value: V): 인자에 해당하는 값가 있으면 true, 아니면 false를 반환한다.
    - get(key: K): 키에 해당하는 값을 반환한다. 존재하지 않으면 null을 반환한다.
  - 가변형 Map 멤버 메소드
    - put(key: K, value: V): 키와 값의 쌍을 Map에 추가한다.
    - remove(key: K): 키에 해당하는 요소를 Map에서 제거한다.
    - putAll(from: Map<out K, V>): 인자로 주어진 Map 데이터를 갱신하거나 추가한다.
    - clear(): 모든 요소를 지운다.
