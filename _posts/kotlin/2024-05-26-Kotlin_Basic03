---
layout: post
title: Kotlin. 
summary: Kotlin Study
author: devhtak
date: '2024-05-26 21:41:00 +0900'
category: Kotlin Study
---

#### 제네릭과 배열
- 제네릭
  ```kotlin
  class Box<T>(var name: T)
  ```
  - 클래스 내부에서 사용할 자료형을 나중에 인스턴스를 생성할 때 확정한다. 
  - 객체의 자료형을 컴파일할 때 체크하기 때문에 객체 자료형의 안정성을 높이고 형 변환의 번거러움을 줄일 수 있다.
  - 제네릭으로 선언된 변수를 프로퍼티를 사용하는 경우 생성자를 통해 초기값을 지정하며, 형식 매개변수는 기본적으로 null을 허용한 형태로 선언된다
    ```kotlin
    fun <T> find(a: Array<T>, target: T): Int {
        for(i in a.indices) {
            if(a[i] == target) return i
        }
        return -1
    }
    ```
  - 람다식을 매개변수로 받으면 자료형을 결정하지 않아도 실행 시 람다식 본문을 넘겨줄 때 결정되어 오류를 해결할 수 있다.
    ```kotlin
    fun <T> add(a: T, b: T, op: (T, T) -> T) = op(a, b)

    fun main() {
        println(add(10, 20) { a, b -> a+b}) // 30
    }
    ```
  - 콜론(:)을 사용하여 매개변수를 받은 특정한 자료형으로 제한할 수 있다.
    ```kotlin
    class Car<T: Number> {
        fun plus(arg1: T, arg2: T): Double= arg1.toDouble() arg2.toDouble()
    }
    fun <T: Number> addNumber(a: T, b: T, op: (T, T) -> T): T = op(a, b)
    ```
  - 상하위 형식의 가변성
    - 가변성이란 형식 매개변수가 클래스 계층에 영향을 주는 것을 만든다.
      - 예를 들어, 형식 A의 값이 필요한 모든 클래스에 B의 값을 넣어도 아무 문제 없다면 B는 A의 하위 형식이 된다.
    - Any <- Int <- Notiing
    - 무변성: 자료형 사이의 하위 관계가 성립되지 않는다.
      - 코틀린에서는 따로 지정해주지 않으면 기본적으로 무변성이다.
      ```kotlin
      class Box<T>(val size: Int)
      fun main() {
          val anys1: Box<Any> = Box<Int>(10) // 오류 / 자료 불일치
          val anys2: Box<Noting> = Box<Int>(10) // 오류 / 자료 불일치
      }
      ```
    - 공변성(out keyword): 형식 매개변수 사이의 하위 자료형 관계가 성립하고, 그 관계가 인스턴스 자료형 관계로 이어진다.
    - 반공변성(in keyword): 공변성과 반대 개념
      ```kotlin
      class BoxOut<out T>(val size: Int)
      class BoxIn<in T>(val size: Int)
      fun main() {
          val anyOut: Box<Any> = Box<Int>(10) // 공변성
          var anyIn: Box<Noting> = Box<int>(20) // 반공변성
      }
    - 가변성의 두가지 방법
      ```kotlin
      class Box<in T:Animal>(var item: T)
      ```
      - 선언 지점 변성(Declaration-Site Variance): 클래스 자체에 가변성을 지정하는 방식이다.
      ```kotlin
      class Box<T>(var item: T)
      fun <T> printBox(box: Box<out Animal>) {
          val object: Animal = box.item
          println(object);
      }
      - 사용 지점 변성(Use-Site Variance): 메서드의 매개변수나 제네릭 클래스를 생성할 때와 같이 사용 위치에서 가변성을 지정하는 방식이다.
    - 자료형 프로젝션(Type Projection): 사용하고자 하는 요소의 특정 자료형에 in 또는 out을 지정해 제한하는 것을 말한다. 자료형 프로젝션을 통해 자료의 안정성을 보장한다.
    - 스타 프로젝션(Star Projection): 어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되면 그 자료형과 하위 자료형의 요소만 허용한다.
      - in으로 정의된 형식 매개변수를 *로 받으면 in Nothing으로 간주
      - out으로 정의된 형식 매개변수를 *로 받으면 out Any?으로 간주
    - refied 자료형
      ```kotlin
      fun main() {
          println(getType<Float>(10)); // 10
      }
      inner fun <reified T> getType(value: Int>:T {
          return when(T::class) {
              Float::class -> value.toFloat() as T
              Int::class -> value ad T
              else -> throw IllegalStateException()
          }
      }
      ```
      - inline 함수에서 형식 매개변수를 실행 시간에 직접 접근하기 위해 사용      
- 배열
  - kotlin은 배열을 여러 가지 자료형을 혼합하여 구성할 수 있으며 다차원 배열 선언도 가능하다 
    ```kotlin
    val numbers = arrayOf(6, 8, "Kim", "Lee")
    var arr2D = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6), arrayOf(7, 8, 9))

    val evenArray = Array<Int>(5) {it * 2} // [0, 2, 4, 6, 8] 
    val array1 = arrayOfNulls<Int>(100) // 100개의 null로 채워진 정수 배열
    val array2 = Array<Int>(1000) {0} // 1000개의 0으로 채워진 정수 배열
    ```
  - 배열 접근은 get, set 또는 \[index] 로 가능하다
    ```kotlin
    public class Array<T> {
        public inline constructor(size: Int, init: (Int) -> T)
        public operator fun get(index: Int): T
        public operator fun set(index: Int, value: T): Unit
        public operator fun size(): Int
        public operator fun iterator(): Iterator<T>
    }
    array.get(index)
    array.set(index, value)
    value = array[index]
    array[index] = value
    ```
  - 다양한 방법의 배열 다루기
    - 배열에 요초 추가 및 잘라내기
      ```kotlin
      var arr1 = arrayOf<Int>(1, 2, 3)
      var arr2 = arr1.plus(4) // 1, 2, 3, 4
      var arr3 = arr1.sliceArray(1..2) // 2, 3
      ```
    - 배열 순환
      ```kotlin
      var arr1 = arrayOf<Int>(1, 2, 3)
      arr1.forEach {e -> println("$e"}
      arr1.forEachIndexed {i, e -> println("array[$i]: $e")}
      var iter: Iterator<Int> = array.iterator()
      while(iter.hasNext()) {
          val e = iter.next()
          println("$e")
      }
      ```
    - 오름차순 정렬
      - 일반 배열로 반환: sortedArray(), 원본배열정렬: sort()
    - 내림차순 정렬
      - 일반 배열로 반환: sortedArrayDescending(), 원본 배열 정렬: sortDescending()
    - sortBy를 이용한 특정 표현식 사용
      items.sortBy { item -> item.length }
    - 배열 필터링
      - filter {it > 0}
    - 배열 평탄화
      - flatten() // 1차원 배열
- 문자열 다루기
  - 문자열은 불변(immutable) 값으로 생성되기 때문에 참조되고 있는 메모리가 변경될 수 없다. 더 이상 참조되지 않는 문자열은 GC(Garbage Collector)에 의해 제거된다.
  - 문자열 추출
    - String.substring(index_범위): String
    - CharSequence.subSequence(index_범위): CharSequence
  - 문자열 비교
    - stringA.compareTo(stringB) // A==B: 0, A<B: 음수, A<B양수
    
