---
layout: post
title: 더 자바 테스트1. JUnit
summary: HTTP 완벽 가이드
author: devhtak
date: '2021-02-07 21:41:00 +0900'
category: 더 자바, 애플리케이션을 테스트하는 다양한 방법
---

#### JUnit 5

- 자바 개발자가 가장 많이 사용하는 테스팅 프레임워크
- Java 8 이상을 필요로 한다.
- 대체제로 TestNG, Spock 등이 있다.
- 구성
  - Platform: JUnit으로 작성한 테스트 코드를 실행해주는 런처 제공, TestEngine API 제공
  - Jupiter: TestEngine API 구현체로 JUnit5 제공
  - Vintage: JUnit3, 4를 지원하는 TestEnging 구현체

- 참고: https://junit.org/junit5/docs/current/user-guide/

#### JUnit 5 시작하기

- Spring Boot 2.2+ 이상의 프로젝트를 만든다면 기본으로 JUnit5 의존성이 추가된다.
- JUnit4까지는 class, test method가 모두 public 접근지시자야 했지만 JUnit5 부터는 class, test method가 default 접근지시자여도 괜찮다.
- dependency 추가
  ```
  <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.5.2</version>
      <scope>test</scope>
  </dependency>
  ```
- 기본 애노테이션
  - @Test
    - 테스트 메소드에 붙여준다.
  - @BeforeAll / @AfterAll
    - static void로 작성해야 한다. 
    - 접근 지시자는 private은 안되고, 나머지는 가능하다.
    - 테스트 코드가 시작되기 전, 후에 한번씩 실행된다.
  - @BeforeEach / @AfterEach
    - 접근 지시자는 private은 안되고, 나머지는 가능하다.
    - 테스트 메소드가 시작하기 전, 후에 각각 실행된다.
  - @Disabled
    - 테스트를 실행하고 싶지 않은 경우에 사용한다.
  
  ```java
  public class StudyTest {	
      @BeforeAll
      static void beforeAll() {
          System.out.println("beforeAll");
      }
      @AfterAll
      static void afterAll() {
          System.out.println("afterAll");
      }
      @BeforeEach
      void beforeEach() {
          System.out.println("beforeEach");
      }
      @AfterEach
      void afterEach() {
          System.out.println("afterEach");
      }
      @Test
      void createInstance() {
          Study study = new Study();
          assertNotNull(study);
      }
      @Test
      void sampleTest() {
          System.out.println("Hello JUnit5");
      }
  }
  ```
  ```
  // 출력 화면
  beforeAll
  beforeEach
  Hello JUnit5
  afterEach
  beforeEach
  afterEach
  afterAll
  ```

#### 테스트 이름 표시하기

- @DisplayNameGeneration
  - Mehtod와 Class 레퍼런스를 사용해서 테스트 이름을 표기하는 방법 설정
  - 기본 구현체로 ReplaceUnderscores 제공
  
- @DisplayName
  - 어떤 테스트인지 테스트 이름을 보다 쉽게 표현할 수 있는 방법을 제공하는 애노테이션
  - @DisplayNameGeneration 보다 우선 순위가 높다.
  
```java
@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
public class StudyTest {
    @Test
    @DisplayName("스터디_만들기")
    void test() {
        System.out.println("test");
    }
}
```
  - @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    - create_instance를 create instance로 보이게 한다.
  
- 참고: https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names

#### Assertion

- Assertion 메소드
  - 패키지: org.junit.jupiter.api.Assertions.*
  
  |메소드|설명|
  |---|---|
  |assertEquals(expected, actual)|실제 값이 기대한 값과 같은지 확인|
  |assertNotNull(actual)|값이 null이 아닌지 확인|
  |assertTrue(boolean)|다음 조건이 참(true)인지 확인|
  |assertAll(excutables...)|모든 확인 구문 확인|
  |assertThrows(expectedTyupe, excutable)|예외 발생 확인|
  |assertTimeout(duration, excutable)|특정 시간 안에 실행이 완료되는지 확인|
  
  - 파라미터의 순서는 보통은 기대값, 비교하고자 하는 값을 입력한다. 
  
- 마지막 매개변수로 Supplier<String> 타입의 인스턴스를 람다 형태로 제공할 수 있다.
  - 복잡한 메시지 생성해야 하는 경우 사용하면 실패한 경우에만 해당 메시지를 만들게 할 수 있다.
- 다른 다양한 라이브러리를 사용할 수 있다.
  - AssertJ: https://joel-costigliola.github.io/assertj
  - Hemcrest: https://hamcrest.org/JavaHamcrest/
  - Truth: https://truth.dev/

```java
@Test
void create_instance() {
    Study study = new Study();
    assertNotNull(study);
    assertEquals(StudyStatus.DRAFT, study.getStatus(), new Supplier<String>() {
        @Override
        public String get() {
            // TODO Auto-generated method stub
            return null;
        }			
    }); //lambda 변환 가능 () -> "message";

    assertTrue(study.getLimit() >= 0, () -> "스터디 최소 참가자는 0 이상이어야 합니다.");

    assertAll(
        ()-> assertNotNull(study),
        ()-> assertEquals(StudyStatus.DRAFT, study.getStatus()),
        ()-> assertTrue(study.getLimit() >= 0, () -> "스터디 최소 참가자는 0 이상이어야 합니다.")
    );

    Exception e = assertThrows(IllegalArgumentException.class, ()-> study.setLimit(-10));
    assertEquals("limit은 0 이상이어야 한다.", e.getMessage());

    assertTimeout(Duration.ofMillis(100), ()->{
        new Study();
        Thread.sleep(1000);
    });

    assertTimeoutPreemptively(Duration.ofMillis(100), ()->{
        new Study();
        Thread.sleep(1000);
    });
}
```
- assertAll은 여러 assertion을 람다식으로 구현하여 한번에 테스트할 수 있다.
- assertThrows는 발생한 Exception 을 리턴한다.
- assertTimeout은 excutable이 완료될 때까지 기다린 후에 완료되기 때문에, 시간이 오래 걸린다.
  - assertTimeoutPreemptively(duration, excutable)
    - 정해놓은 Duration만큼만 기다리고 실패하면 바로 끝낸다.
    - 별도의 thread를 만들어 사용한다.
    - ThreadLocal(Spring Transaction 등)을 사용하면 예상치 못한 결과를 얻을 수 있다.
    - 다른 스레드에서 ThreadLocal이 공유되지 않기 때문에 트랜잭션 설정이 제대로 안될 수 있다. 기본 rollback인데 commit이 될 수도 있다.
    - 이 동작은 executable 또는 내부에서 실행되는 코드가 스토리지에 supplier의존 하는 경우 바람직하지 않은 부작용을 초래할 수 있다.
