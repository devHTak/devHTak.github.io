---
layout: post
title: 네트워크 프로그래밍 06. UDP와 멀티캐스팅
summary: 네트워크 프로그래밍
author: devhtak
date: '2022-12-21 22:41:00 +0900'
category: java
---
#### UDP와 멀티캐스팅
- UDP(User Datagram Protocol)은 TCP에 비교해 패킷이 의도한 목적지에 도착한다는 보장, 순서의 보장을 할 수 없기 때문에 신뢰할 수 없다.
- 비연결 프로토콜로 패킷 전송을 용이하게 하는 두개의 노드간의 메시지 교환이 없다.
- DNS, NTP, VOIP, P2P 네트워크에서 네트워크 통신의 조정, 비디오 스트리밍 등에 사용된다

##### UDP에 대한 자바 지원
- DatagramSocket: 노드간에 소켓 연결 생성
- DatagramPacket: 데이터 패킷을 나타내며, send, receive 메소드를 통해 네트워크를 통해 패킷 전송
- 노드 식별하는 데 IP, Port 번호 사용
  - 0~1023: 잘 알려진 포트
  - 1024~49151: 등록된 포트
  - 49152~65535: 동적/사설 포트

- TCP와 UDP
  - 차이점 1. 신뢰성: TCP는 UDP 보다 더 신뢰할 수 있다
  - 차이점 2. 순서: TCP는 패킷 전송의 순서가 유지되는 것을 보장
  - 차이점 3. 헤더 크기: UDP 헤더는 TCP 헤더보다 작다
  - 차이점 4. 속도: UDP는 TCP 보다 빠르다
  
##### UDP Server/Client

- 서버 측에서는 생성된 UDP 서버 소켓은 클라이언트 요청을 기다리며, 클라이언트는 응답하는 UDP 소켓을 생성하고 서버에게 메세지를 전송하는 데 사용. 서버는 요청을 처리하고 응답을 재전송 할 수 있다
- receive 메소드는 응답할때까지 블록되며 패킷은 이후에 채워진다
- UDP Server
  ```java
  System.out.println("UDP Server Started");
  /** DatagramSocket 생성하는 다른 방법
   * DatagramSocket socket = new DatagramSocket(null);
   * socket.bind(new InetSocketAddress(9003);
   */
  try(DatagramSocket socket = new DatagramSocket(9003)) {
      while(true) {
          byte[] receiveMessage = new byte[64]; // 바이트 배열 생성
          DatagramPacket packet = new DatagramPacket(receiveMessage, receiveMessage.length); // DatagramPacket 인스턴스 생성
          socket.receive(packet); // 도착 메세지의 대기를 위한 DatagramSocket 인스턴스 사용
          String message = new String(packet.getData());
          System.out.println("Received Data: " + message);

          // 응답 전송 - 클라이언트 주소, Port 사용
          InetAddress address = packet.getAddress();
          int port = packet.getPort();
          byte[] sendMessage = message.getBytes();
          DatagramPacket sendPacket = new DatagramPacket(sendMessage, sendMessage.length, address, port);
          socket.send(sendPacket);
      }
  } catch (IOException e) {
      // 예외 처리
  }
  System.out.println("UDP Server Terminating");
  ```
- UDP Client
  ```java
  System.out.println("UDP Client Started");
  Scanner scanner = new Scanner(System.in);

  try(DatagramSocket socket = new DatagramSocket()) {
      InetAddress address = InetAddress.getByName("127.0.0.1");
      int port = 9003;
      byte[] sendMessage;

      while(true) {
          System.out.print("Enter a message: ");
          String message = scanner.nextLine();
          if("quit".equals(message)) {
              break;
          }

          // 서버로 데이터 전달
          sendMessage = message.getBytes();
          DatagramPacket packet = new DatagramPacket(sendMessage, sendMessage.length, address, port);
          socket.send(packet);

          // 서버에게 데이터 받음
          byte[] receiveMessage = new byte[1024];
          DatagramPacket receivePacket = new DatagramPacket(receiveMessage, receiveMessage.length);
          socket.receive(receivePacket);
          message = new String(receivePacket.getData());
          System.out.println("Received Data: " + message);
      }
      socket.close();
  } catch (IOException e) {
      // 예외처리
  }
  System.out.println("UDP Client Terminated");
  ```
  
##### UDP를 위한 채널 지원

- DatagramChannel 은 UDP에 대한 추가 지원 제공하며 nonblocking interchanges 지원
  - 쉽게 멀테스레드 애플리케이션을 생성하는 SelectableChannel 클래스에서 파생
- DatagramSocket 클래스는 채널을 포트에 바인딩하여 사용하며 DatagramSocket은 직접적으로 사용되지 않는다
  - DatagramPacket 또한 직접 사용하지 않으며 Buffer를 사용
  
- UDP Echo Server
  ```java
  System.out.println("UDP Echo Server Started");

  try(DatagramChannel channel = DatagramChannel.open();
      DatagramSocket socket = channel.socket()) {

      SocketAddress address = new InetSocketAddress(9000);
      socket.bind(address);

      ByteBuffer buffer = ByteBuffer.allocateDirect(65507); // allocateDirect는 버퍼 할당에서 네이티브 OS 지원을 사용하려고 시도한다
      while(true) {
          // 메시지 얻기
          SocketAddress client = channel.receive(buffer); // 클라이언트 메시지를 얻기 위한 채널에 적용, 수신될 때까지 블록된다
          buffer.flip(); // 처리를 위한 버퍼를 사용 가능하게 한다. limit을 현재 position으로 설정하고 이후 position 0으로 설정

          // 메시지 출력
          buffer.mark(); // mark 현재 position으로 마킹한다
          StringBuilder message = new StringBuilder();
          while(buffer.hasRemaining()) {
              message.append((char)buffer.get());
          }
          System.out.println("Received: " + message.toString());
          buffer.reset(); // 마크된 position으로 복원

          // 메시지 반환
          channel.send(buffer, client);
          System.out.println("Send: " + message);
          buffer.clear(); // position을 0으로 설정하고, limit을 capacity로 설정, 마크 삭제
      }
  } catch (IOException e) {
      // 예외 처리
  }
  System.out.println("UDP Echo Server Terminated");
  ```
  
- UDP Echo Client
  ```java
  Scanner scanner = new Scanner(System.in);
  System.out.println("UDP Echo Client Started");
  try {
      SocketAddress address = new InetSocketAddress("127.0.0.1", 9000);
      DatagramChannel channel = DatagramChannel.open();
      channel.connect(address);

      while(true) {
          String message = scanner.nextLine();
          if("quit".equals(message)) {
              break;
          }
          ByteBuffer buffer = ByteBuffer.allocate(message.length());
          buffer.put(message.getBytes());

          buffer.flip(); // limit을 현재의 position으로 설정하고 position을 0으로 설정
          channel.write(buffer);
          System.out.println("Send: " + message);

          buffer.clear();
          channel.read(buffer);
          buffer.flip();
          StringBuilder receivedMessage = new StringBuilder();
          while(buffer.hasRemaining()) {
              receivedMessage.append((char)buffer.get());
          }
          System.out.println("Received: " + receivedMessage.toString());
      }
  } catch (IOException e) {
      // 예외 처리
  }
  System.out.println("UDP Echo Client Terminated");
  ```

##### UDP Multicasting
