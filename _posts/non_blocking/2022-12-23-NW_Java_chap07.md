---
layout: post
title: 네트워크 프로그래밍 07. 네트워크 확장성
summary: 네트워크 프로그래밍
author: devhtak
date: '2022-12-23 22:41:00 +0900'
category: java
---
#### 네트워크 확장성

##### 멀티스레드 서버

- 요청을 위한 별도의 스레드를 사용하는 것은 접속과 관련된 요청이 동시에 처리될 수 있다
- 스레드 구성 방법
  - 요청별 스레드
    - 서버에 도착하는 각 요청을 새 스레드로 할당되며 각 요청은 종종 새로운 연결이 생성되는 것을 의미한다
    - 요청이 유지될 필요가 없는 환경에서 잘 작동한다
  - 연결별 스레드
    - 클라이언트 연결은 세션 기간 동안 유지된다
    - 세션은 요청 및 응답으로 구성되며 특정 커멘드, 타임아웃 기간 이후에 종료된다
  - 객체별 스레드
    - 관련 요청을 처리할 수 있는 특정 객체와 함께 대기열에 넣는다
    - 객체와 그 메소드는 한 번에 하나의 요청을 처리하는 스레드에 위치하며, 요청은 스레드에서 대기한다. 
    - 스레드 풀에서 종종 사용된다.

- 요청별 스레드
  - 병렬을 접속을 지원하는 ConcurrentHashMap 사용하며 애플리케이션의 성능을 개선하는 데 유용할 수 있다
  - main 메소드에서 소버 소켓이 클라이언트 요청을 대기하고 클라이언트 소켓이 처리를 위한 스레드로 전달하는 새로운 스레드로 생성
  ```java
  public class SimpleMultiThreadServer implements Runnable {
      private static ConcurrentHashMap<String, Float> map;
      private Socket clientSocket;
      static {
          map = new ConcurrentHashMap<>();
          map.put("Axle", 238.50f);
          map.put("Gear", 45.55f);
          map.put("Wheel", 86.30f);
          map.put("Rotor", 8.50f);
      }
      public SimpleMultiThreadServer(Socket clientSocket) {
          this.clientSocket = clientSocket;
      }
      @Override
      public void run() {
          System.out.println("Client Thread Started");
          try(BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
              PrintStream out = new PrintStream(clientSocket.getOutputStream())) {

              String partName = br.readLine();
              out.println(map.get(partName));
              System.out.println("Request for " + partName + "and returned price is " + map.get(partName));
              clientSocket.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
          System.out.println("Client Thread Terminated");
      }
      public static void main(String[] args) {
          System.out.println("Multi-Threaded Server Started");
          try {
              ServerSocket serverSocket = new ServerSocket(5000);
              while (true) {
                  System.out.println("Listeneing for a client connection");
                  Socket clientSocket = serverSocket.accept();
                  new Thread(new SimpleMultiThreadServer(clientSocket)).start();;
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
          System.out.println("Multi-Threaded Server Terminated");
      }
  }
  ```
- 클라이언트
  ```java
  System.out.println("Client started");
  Scanner scanner = new Scanner(System.in);
  try {
      Socket socket = new Socket("127.0.0.1", 5000);
      BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      PrintStream ps = new PrintStream(socket.getOutputStream());

      System.out.print("Part Name: ");
      String partName = scanner.nextLine();
      ps.println(partName);;
      System.out.println(partName + " request sent. Response: " + br.readLine());
      socket.close();
  } catch (IOException e) {
      e.printStackTrace();
  }
  System.out.println("Client Terminated");
  ```
  
- 연결별 스레드 접근법
  - 서버
    - 타임아웃은 충분한 시간이 경과한 후 자동으로 클라이언트의 연결을 해제하게 설정될 필요가 잆다
    - 현재 quit 이 요청되면 루프는 종료되며 그 외 요청은 이전과 동일하게 처리된다
    ```java
    @Override
    public void run() {
        System.out.println("Client Thread Started");
        Socket socket = serverSocket.accept();
        BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        PrintStream out = new PrintStream(clientSocket.getOutputStream())
        while(true) {
            String partName = br.readLine();
            if("quit".equals(partName) {
                break; 
            }
            out.println(map.get(partName));
            System.out.println("Request for " + partName + "and returned price is " + map.get(partName));
            clientSocket.close();
        }
        System.out.println("Client Thread Terminated");
    }
    ```
##### 스레드풀
- 풀은 많은 스레드가 생성되는 방법을 제어하며 비용이 많이 드는 작업에서 반복적으로 요청되는 스레드를 생성하고 파괴하는 작업을 생략할 수 있다
- 요청은 풀에서 스레드에게 할당되며, 스레드가 없다면 일부 스레드 풀은 새 스레드를 생성할 수도 있고, 그 외에는 이용가능한 스레드 수를 제한한다. 일부 요청에서 블록된 결과가 발생할 수 있다
- ThreadPoolExecutor 클래스는 스레드 실행에 대한 상태 정보를 전달하는 메소드를 제공한다
  - 생성 메소드
    - newCachedThreadPool(생성된 풀은 스레드를 재사용하며 필요한 경우 새로운 스레드를 생성)
    - newFixedThreadPool(고정된 크기의 풀을 생성)
  - 풀 종료
    - ThreadPoolExecutor 클래스의 인스턴스가 생성되면 스레드 풀에 전달되는 새로운 작업을 수락할 것이나 풀은 자동으로 닫히지 않는다.
    - 유휴상태의 경우 새 작업이 전송될 때까지 기다리며 풀을 종료하기 위해서는 shutdown, shutdownNow 메소드가 호출 되어야 한다
    - shutdownNow 는 바로 풀을 종료하고 대기 중인 작업을 실행하지 않는다
  - 스레드 풀 정보
    - getPoolSize: 풀에서 현재 스레드의 수를 반환
    - getActiveCount: 활성 스레드의 수를 반환
    - getLargePoolSize: 한번에 풀에서의 최대 스레드의 수를 반환

- 서버
  - ThreadPoolExecutor 생성하여 요청 스레드 생성
    ```java
    System.out.println("Thread Pool Server Started");
    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();

    try {
        ServerSocket serverSocket = new ServerSocket(5000);
        while(true) {
            System.out.println("Listening for a client connection");
            Socket clientSocket = serverSocket.accept(); // 연결 요청이 올 때까지 블록된다

            executor.execute(new WorkerThread(clientSocket));
        }
    } catch (IOException e) {
        e.printStackTrace();
    }

    executor.shutdown();
    System.out.println("Thread Pool Server Terminated");
    ```
  - 요청 스레드(WorkerThread)
    ```java
    public class WorkerThread implements Runnable {
        private static ConcurrentHashMap<String, Float> map;
        private Socket clientSocket;
        static {
            map = new ConcurrentHashMap<>();
            map.put("Axle", 238.50f);
            map.put("Gear", 45.55f);
            map.put("Wheel", 86.30f);
            map.put("Rotor", 8.50f);
        }
        public WorkerThread(Socket clientSocket) {
            this.clientSocket = clientSocket;
        }
        @Override
        public void run() {
            System.out.println("Worker Thread Started");
            try(BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                PrintStream out = new PrintStream(clientSocket.getOutputStream())) {

                String partName = br.readLine();
                out.println(map.get(partName));
                System.out.println("Request for " + partName + ", price: " + map.get(partName));
                clientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            System.out.println("Worker Thread Started");
        }
    }
    ```
  - 클라이언트는 요청별 스레드와 동일

- Callable 과 스레드 풀
  - Callable, Future 인터페이스는 멀티스레드를 지원하는 또 다른 접근 방법을 제공한다
    - Callable은 스레드가 결과를 반환해야 하는 스레딩을 지원하며 Runnable 인터페이스에 run 메소드를 대신해 사용되는 call 메소드 보유
    - Future 인터페이스는 Callable 객체와 함께 사용
  - Callable
    - 다른 스레드가 생성되는 동안 call 메소드가 반환될 때까지 블록되며 Future 인터페이스를 통해 기술을 향상시킬 수 있다
    ```java
    public class WorkerThread implements Runnable {
        private Socket clientSocket;
        public WorkerThread(Socket clientSocket) {
            this.clientSocket = clientSocket;
        }
        @Override
        public void run() {
            System.out.println("Worker Thread Started");
            try(BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                PrintStream out = new PrintStream(clientSocket.getOutputStream())) {

                String partName = br.readLine();
                float price = new WorkerCallable(partName).call();
                out.println(price);
                System.out.println("Request for " + partName + ", price: " + price);
                clientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("Worker Thread Started");
        }
    }

    public class WorkerCallable implements Callable<Float> {
        private static ConcurrentHashMap<String, Float> map;
        private String partName;
        static {
            map = new ConcurrentHashMap<>();
            map.put("Axle", 238.50f);
            map.put("Gear", 45.55f);
            map.put("Wheel", 86.30f);
            map.put("Rotor", 8.50f);
        }
        public WorkerCallable(String partName) {
            this.partName = partName;
        }
        @Override
        public Float call() throws Exception {
            return map.get(partName);
        }
    }
    ```
  - Future
    - 완료된 call 매소드의 결과를 나타낸다
    - Future 인터페이스를 사용해 Callable 객체를 호출하고 반환될 떄까지 기다리지 않을 수 없다
    ```java
    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();
    Future<Float> future1 = executor.submit(() -> 1.0f);
    Future<Float> future2 = executor.submit(() -> 2.0f);
    try {
        Float price1 = future1.get(); // 1.0
        Float price2 = future2.get(); // 2.0
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
    ```
  - CompletableFuture 
  - CompletionStage

- HTTPServer 에서 스레드 풀 사용하기
  - HTTPServer 에서는 기본적으로는 start 메소드가 호출될 때 생성된 스레드 사용
  - setExecutor 메소드를 사용하여 요청을 스레드에 할당하는 방법을 지정할 수 있다.
    ```java
    HttpServer server = HttpServer.create(new InetSocketAddress(80), 0);
    server.createContext("/index", new OtherHandler();
    server.setExecutor(Executors.newCachedThreadPool());
    server.start();
    ```

##### 셀렉터 사용

##### 네트워크 타임아웃 설정
