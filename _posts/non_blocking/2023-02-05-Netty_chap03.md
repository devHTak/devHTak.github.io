---
layout: post
title: Netty. Network Protocol(feat. Netty in action)
summary: 네트워크 프로그래밍
author: devhtak
date: '2022-02-05 22:41:00 +0900'
category: java
---

#### chap12. 웹소켓

##### 웹소켓 소개

- WebSocket 프로토콜은 웹의 양방향 데이터 전송 문제에 대한 실용적인 솔루션을 제공하기 위해 클라이언트/서버가 언제든 메시지를 전송할 수 있게 허용
- 결과적으로 메시지 수신을 비동기적으로 처리하게 요구하도록 새롭게 설치

##### 웹소켓 애플리케이션
- 채팅방 작동 방식
  - 클라이언트가 서버에 연결하고 채팅에 참여
  - 채팅 메시지가 웹소켓을 통해 교환되며 양방향으로 전송
  - 서버가 모든 클라이언트를 처리

##### 웹소켓 지원 추가
- 예제
  - / 로 요청: index.html 전송
  - /ws 로 요청: 서버가 웹소켓 업그레이드 수행, 연결이 업그래이드 되면 모든 데이터를 웹소켓을 이용해 전송
  - 요청 방식
    - 채팅방 클라이언트가 HTTP 요청(/ 또는 /ws)
    - 채팅방 서버는 / 요청인 경우 HTTP 를 통해 index.html wjsthd
    - 채팅방 서버는 /ws 요청인 경우 웹소켓 업그레이드 수행(HTTP를 통해 웹소켓 핸드셰이크 작업)
    - 업그레이드 완료 후 서버가 웹소켓을 통해 메시지 전송
- HTTP 요청 처리시
  ```java
  public class HttpRequestHandler extends SimpleChannelInboundHandler<FullHttpRequest> { // FullHttpRequest를 처리하기 위한 핸들러
      private final String wsUri;
      private static final File INDEX;

      static {
          URL location = HttpRequestHandler.class.getProtectionDomain()
                  .getCodeSource().getLocation();
          try {
              String path = location.toURI() + "index.html";
              path = !path.contains("file:") ? path : path.substring(5);
              INDEX = new File(path);
          } catch (URISyntaxException e) {
              throw new IllegalStateException("Unable to locate index.html", e);
          }
      }

      public HttpRequestHandler(String wsUri) {
          this.wsUri = wsUri;
      }

      @Override
      protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {
          if(wsUri.equalsIgnoreCase(msg.getUri())) {
              ctx.fireChannelRead(msg.retain()); // /ws 를 참조하는 경우 FullHttpRequest retain을 호출한 후 fileChannelRead(msg)를 호출해 다음 ChannelInboundHandler 전달
          } else { // / index.html 전달
              if(HttpHeaders.is100ContinueExpected(msg)) { // 100-continue에 경우 100 Continue 응답 전송
                  send100Continue(ctx);
              }
              RandomAccessFile file = new RandomAccessFile(INDEX, "r"); // index.html을 읽는다
              HttpResponse response = new DefaultHttpResponse(msg.getProtocolVersion(), HttpResponseStatus.OK);
              response.headers().set(HttpHeaders.Names.CONTENT_TYPE, "text/plain;charset=UTF-8");
              if(HttpHeaders.isKeepAlive(msg)) { // keep-alive 요청이 있는 경우 필요한 헤더 추가
                  response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, file.length());
                  response.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);
              }
              ctx.write(response); // HttpResponse를 클라이언트로 기록
              if(ctx.pipeline().get(SslHandler.class) == null) {
                  ctx.write(new DefaultFileRegion(file.getChannel(), 0, file.length()));
              } else {
                  ctx.write(new ChunkedNioFile(file.getChannel()));
              }
              ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); // LastHttpContent 를 클라이언트에 기록하고 플러시
              if(!HttpHeaders.isKeepAlive(msg)) { // keep-alive 요청이 없는 경우 Channel을 닫음
                  future.addListener(ChannelFutureListener.CLOSE);
              }
          }
      }
      private void send100Continue(ChannelHandlerContext ctx) {
          FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);
          ctx.writeAndFlush(response);
      }

      @Override
      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
          cause.printStackTrace();
          ctx.close();
      }
  }
  ```
- 웹소켓 프레임 처리
  ```java
  public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
      private final ChannelGroup channelGroup;
      public TextWebSocketFrameHandler(ChannelGroup channelGroup) {
          this.channelGroup = channelGroup;
      }
      @Override
      public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { // 커스텀 이벤트를 처리하기 위해 userEventTriggered() 재정의
          if(evt == WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) {
              ctx.pipeline().remove(HttpRequestHandler.class); // 이벤트가 핸드세이크 성공을 의미하는 경우 HTTP Message는 더이상 수신하지 않으므로 ChannelPipeline에서 HttpRequestHandler 제거
              channelGroup.writeAndFlush(new TextWebSocketFrame("Client " + ctx.channel() + " joined.")); // 연결된 모든 웹소켓 클라이언트에 새로운 클라이언트가 연결된 것을 알림
              channelGroup.add(ctx.channel()); // 모든 메시지를 수신할 수 있게 새로운 웹소켓 채널을 추가
          } else {
              super.userEventTriggered(ctx, evt);
          }
      }
      @Override
      protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
          channelGroup.writeAndFlush(msg.retain()); // 메시지의 참조 카운트를 증가시키고 ChannelGroup에 연결된 모든 클라이언트로 기록
      }
  }
  ```
  - WebSocketFrame 형식
    - BinaryWebSocketFrame: 이진 데이터 포함
    - TextWebSocketFrame: 텍스트 데이터 포함
    - ContinuationWebSocketFrame: 이진 데이터 또는 텍스트 데이터 포함
    - CloseWebSocketFrame: CLOSE 요청을 나타내며, 닫기 상태 코드와 구문 포함
    - PingWebSocketFrame: PongWebSocketFrame 전송 요청
    - PongWebSocketFrame: PingWebSocketFrame 에 대한 응답 전송
- ChannelPipeline 초기화
  ```java
  public class ChatServerInitializer extends ChannelInitializer<Channel> {
      private final ChannelGroup channelGroup;
      public ChatServerInitializer(ChannelGroup channelGroup) {
          this.channelGroup = channelGroup;
      }

      @Override
      protected void initChannel(Channel ch) throws Exception {
          ChannelPipeline pipeline = ch.pipeline();
          pipeline.addLast(new HttpServerCodec());
          pipeline.addLast(new ChunkedWriteHandler());
          pipeline.addLast(new HttpObjectAggregator(64 * 1024));
          pipeline.addLast(new HttpRequestHandler("/ws"));
          pipeline.addLast(new WebSocketServerProtocolHandler("/ws"));
          pipeline.addLast(new TextWebSocketFrameHandler(channelGroup));
      }
  }
  ```
  - pipeline 구성
    - HttpServerCodec: 바이트를 HttpRequest, HttpContent, LastHttpContent로 디코딩, HttpRequest, HttpContent, LastHttpContent를 바이트로 인코딩 
    - ChunkedWriteHandler: 파일의 내용을 기록
    - HttpObjectAggregator: HttpMessage 및 해당하는 후속 HttpContent를 집계해 요청이나 응답을 처리하는지에 따라 단일 FullHttpRequest, FullHttpResponse를 생성한다. 이는 파이프라인의 다음 ChannelHandler는 완전한 HTTP 요청만 받는다
    - HttpRequestHandler: /ws URL로 보내지 않는 요청에 해당하는 FullHttpRequest를 처리
    - WebSocketServerProtocolHandler: 웹소켓 사양에서 요구하는 대로 웹소켓 업그레이드 핸드셰이크 PingWebSocketFrame, PongWebSocketFrame, CloseWebSocketFrame 처리 
    - TextWebSocketFrameHandler: TextWebSocketFrame 및 핸드셰이크 완료 이벤트 처리 
- Bootstrap
  ```java
  public class ChatServer {
      private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE); // 연결된 모든 웹소켓 채널을 포함할 DefaultChannelGroup 생성
      private final EventLoopGroup group = new NioEventLoopGroup();
      private Channel channel;

      public ChannelFuture start(InetSocketAddress address) {
          ServerBootstrap serverBootstrap = new ServerBootstrap();
          serverBootstrap.group(group)
                  .channel(NioServerSocketChannel.class)
                  .childHandler(createInitializer(channelGroup));
          ChannelFuture future = serverBootstrap.bind(address);
          future.syncUninterruptibly();
          channel = future.channel();
          return future;
      }

      protected ChannelHandler createInitializer(ChannelGroup channelGroup) { // ChatServerInitializer 생성
          return new ChatServerInitializer(channelGroup);
      }

      public void destroy() {
          if(channel != null) channel.close();
          channelGroup.close();
          group.shutdownGracefully();
      }

      public static void main(String[] args) {
          if(args.length != 1) {
              System.err.println("Please give port as argument");
              System.exit(1);
          }
          int port = Integer.parseInt(args[0]);
          final ChatServer endpoint = new ChatServer();
          ChannelFuture future = endpoint.start(new InetSocketAddress(port));
          Runtime.getRuntime().addShutdownHook(new Thread(){
              @Override
              public void run() {
                  endpoint.destroy();
              }
          });
          future.channel().closeFuture().syncUninterruptibly();
      }
  }
  ```
  
##### 애플리케이션 테스트


#### 출처
- Netty in action(위키북스): 노먼 아운로, 마빈 알렌 울프탈 지음
