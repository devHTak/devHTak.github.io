---
layout: post
title: HTTP 완벽 가이드 15장. 엔터티와 인코딩
summary: HTTP 완벽 가이드
author: devhtak
date: '2021-02-06 12:41:00 +0900'
category: HTTP 완벽 가이드
---

#### 0. 들어가기

- HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되며 처리되는 것을 보장
- HTTP가 보장하는 것
  - 객체는 올바르게 식별되므로(Content-Type 미디어 포맷과 Content-Language 헤더를 이용) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
  - 객체는 올바르게 압축이 풀릴 것이다. (Content-Length와 Content-Encoding 헤더를 이용)
  - 객체는 항상 최신이다.(엔터티 검사기와 캐시 만료 제어 이용)
  - 네트워크 사이를 빠르고 효율적으로 이동(범위 요청, 델타 인코딩, 그외의 데이터 압축을 이용)
  - 조작되지 않고 온전하게 도착할 것이다. (전송 인코딩 헤더와 Content-MD5 체크섬 이요)
  
#### 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
- 엔터티 헤더
  
  |엔터티 헤더|설명|
  |---|---|
  |Content-Type|엔터티에 의해 전달된 객체의 종류|
  |Content-Length|전달되는 메시지의 길이나 크기|
  |Content-Language|전달되는 객체와 가장 잘 대응되는 자연어|
  |Content-Encoding|객체 데이터에 대해 행해진 변형(압축 등)|
  |Content-Location|요청 시점을 기준으로, 객체의 또 다른 위치|
  |Content-Range|만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.|
  |Content-MD5|엔터티 본문의 콘텐츠에 대한 체크섬|
  |Last-Modified|서버에서 이 콘텐츠가 생성 혹은 수정된 날|
  |Expires|이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각|
  |Allow|이 리소스에 대해 어떤 요청 메서드가 허용되는지 ex)GET, HEAD|
  |ETag|인스턴스에 대한 고유한 검사기, 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않다.|
  |Cache-Control|어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지 않다.|
  
- 엔터티 본문
  - 엔터티 본문은 가공되지 않은 데이터만을 담고 있고 다른 정보들은 모두 헤더에 담겨 있다.
  - 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.
  
#### 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
- 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.
  - 만약 gzip으로 압축된 테스트 파일이라면, 원래 데이터 크기가 아닌 압축된 후의 크기이다.

- 잘림 검출
  - 클라이언트는 잘림을 검출하기 위해 Content-Length가 필요하다.
  - 캐싱 프락시 서버에서, 잘린 메시지를 캐시하는 위험을 줄이기 위해 명시적으로 Content-Length를 갖고있지 않은 HTTP 본문은 보통 개시하지 않는다.
    - 잘린 콘텐츠를 저장하여 계속 전송하는 오류가 발생할 수 있다.
    
- 잘못된 Content-Length
  - 잘못된 Content-Length 값은 잘린 컨텐츠 보다 더 큰 피해를 유발할 수 있다.
  
- Content-Length와 지속 커넥션(Persistent Connection)
  - Content-Length는 지속 커넥션을 위해 필수 헤더이다.
    - 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다.
    - Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.
  - 청크 인코딩
    - Content-Length 없는 지속 컨넥션을 만나는 상황
    - 청크 인코딩은 데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보낸다.
    
- 콘텐츠 인코딩
  - 보안을 강화하거나, 압축을 통해 공간을 절약할 수 있도록 엔터티 본문을 인코딩할 수 있게 해준다.
  - 본문이 인코딩되었다면 Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정읳나다.
  
- 엔터티 본문 길이 판별을 위한 규칙
  - 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다. 
    - 이 경우 Content-Length 헤더는 부가정보에 불가하며, 실제 본문 길이를 서술하지 않는다.
  - 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
  - 메시지가 Content-Length 헤더를 갖는다면(그리고 메시지 유형이 엔터티 본문을 허용한다면), Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
    - 만약 Transfer-Encoding 헤더 필드가 있다면 Content-Length 헤더는 무시해야 한다.
  - 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면(Content-Length 헤더로), 멀티파트 메시지의 각 부분은 각자 스스로의 크기를 정의할 것이다.

#### 15.3 엔터티 요약

- TCP/IP를 사용한다 하더라도 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시 등 여러가지의 이유로 전송 중에 변형되는 일이 있다.
- 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 엔터티의 변경을 잡아내기 위해 체크섬으로 기본적인 검사를 할 수 있다.

#### 15.4 미디어 타입과 차셋

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
- MIME 타입

  |미디어 타입|설명|
  |---|---|
  |text/html|HTML 문서|
  |text/plain|플레인 텍스트 문서|
  |image/gif|GIF 이미지|
  |image/jpeg|JPEG 이미지|
  |audio/x-wav|WAV 음향 데이터를 포함|
  |model/vrml|삼차원 VRML 모델|
  |application/vnd.ms-powerpoint|마이크로소프트 파워포인트 프레젠테이션|
  |mulipart/byteranges|여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위를 담고 있다.|
  |message/http|완전한 HTTP 메시지|
  
- 텍스트 매체를 위한 문자 인코딩
  - 엔터티의 비트 집합을 텍스트 하일의 글자들로 변환하기 위한 'charset' 매개변수가 있다.
    ```
    Content-Type: text/html; charset=iso-8859-4
    ```
  
- 멀티파트 미디어 타입
  - MIME 멀티파트 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
  - HTTP는 멀티파트 본문도 지원한다. 그러나 일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용된다.
  
- 멀티파트 폼 제출
  - HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가되어 보내진다.
  - boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.
    ```
    Content-Type: multipart/form-data boundry=[abcdefghiklmnopqrstuvwxyz]
    ```
  
- 멀티파트 범위 응답
  - 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있다.

#### 15.5 콘텐츠 인코딩

- HTTP 애플리케이션은 발송하는 쪽에서 콘텐츠에 인코딩을 적용하여, 엔터티 본문에 담아 수신자에게 보낼 수 있다.

- 콘텐츠 인코딩 과정
  - 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
  - 콘텐츠 인코딩 서버(원 서버 또는 다운스트림 프락시)가 인코딩 된 메시지를 생성한다. 
    - 인코딩 된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 
    - 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩 된 메시지에 추가하여 수신 측 애플리케이션이 디코딩 할 수 있도록 도와준다.
  - 수신 측 애플리케이션은 인코딩 된 메시지를 받아서 디코딩 후 원본을 얻는다.
    ```
    Content-Encoding: gzip
    ```
    - Gzip 콘텐츠 인코더를 통해 인코딩 된 원본을 Gzip 콘텐츠 디코더를 통해 디코딩 하여 원본을 얻는다.
  
- 콘텐츠 인코딩 유형
  - HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
  - Content-Encoding 헤더는 표준화된 토큰 값을 이용해서, 인코딩에 사용된 알고리즘들에 대해 기술한다.
  
  |콘텐츠 인코딩 값|설명|
  |---|---|
  |gzip|엔터티에 GNU zip 인코딩이 적용되었음을 의미|
  |compress|엔터티에 대해 유닉스 파일 압축 프로그램인 'compress'가 실행었엇음을 의미|
  |deflate|엔터티가 zlib 포맷으로 압축되었음을 의미|
  |identity|엔터티에 어떤 인코딩도 수행되지 않았음을 의미 (Content-Encoding 헤더가 없을 경우 이 값)|
  
  - gzip, compress, deflate 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘
  - gzip이 가장 효율적이고 많이 사용됨
  
- Accept-Encoding 헤더
  - 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.
  - Accept-Encoding 헤더를 전달하지 않는다면 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 간주한다. (= Accept-Encoding: *)
  - Accept-Encoding 헤더의 몇 가지 예
    ```
    Accept-Encoding: compress, gzip
    Accept-Encoding:
    Accept-Encoding: *
    Accept-Encoding: compress;q=0.5, gzip;q=1.0
    Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
    ```
  - 클라이언트는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있다. (min: 0.0 ~ max:1.0)
  
#### 15.6 전송 인코딩과 청크 인코딩

  
