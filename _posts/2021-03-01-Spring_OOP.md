---
layout: post
title: 객체 지향 설계와 스프링
summary: 김영한님 - 스프링 핵심 원리_기본편
author: devhtak
date: '2021-03-01 21:41:00 +0900'
category: Spring
---

#### 스프링이란?

- 필수: Spring Framework, Spring Boot
- 선택: Spring Data, Spring Session, Spring Security, Spring Rest Docs, Spring Batch, Spring Cloud ...

- Spring Framework
  - 핵심 기술: DI Container, AOP, Event ...
  - 웹 기술: MVC, WebFlux
  - 데이터 접근 기술: Transaction, JDBC, ORM 지원, XML 지원
  - 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
  - 테스트: 스프링 기반 테스트 지원
  - 언어: 코틀린, 그루비
  - 최근에는 스프링 부트를 통해 스프링 프레임워크의 기술들을 편리하게 사용

- Spring Boot
  - 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
  - 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
  - Tomcat과 같은 웹 서버를 내장하여 별도의 웹 서버를 설치하지 않아도 된다.
  - 손시윈 빌드 구성을 위한 starter 종속성 제공
  - 스프링과 Third Party(외부) 라이브러리 자동 구성
  - 메트린, 상태 확인, 외부 구성같은 프로덕션 준비 기능 제공
  - 관례에 의한 간결한 설정
  
- Spring의 핵심
  - Java 기반의 프레임워크다.
    - Java의 가장 큰 특징: 객체 지향 언어
  - Spring은 객체 지향 언어가 가장 강력한 특징을 살려내는 프레임워크
  - 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
  
#### 좋은 객체 지향 프로그래밍이란?

- 객체 지향 특징
  - 추상화
  - 캡슐화
  - 상속
  - 다형성

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나, 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다.(협력)
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
  - 유연하고 변경이 용이하다? -> 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법 -> 다형성

- 다형성의 실세계 비유
  - 실세계와 객체 지향을 1:1로 매칭하기는 어렵다.
  - 역할과 구현으로 세상을 구분하면 이해하기 쉽다.
  - 예제 - 운전자와 자동차
    - 운전자 역할 vs 자동차 역할
      - (자동차 구현1) K3
      - (자동차 구현2) 아반테
      - (자동차 구현3) 테슬라 모델3
    - 자동차가 바뀌어도 운전자에 운전 능력에 영향을 미치지 않는다.
      - 어떻게? 운전자는 자동차의 역할 중 엑셀, 브레이크 등의 기능을 알고 있고, 해당 기능으로 운전할 수 있다.
      - 하지만? K3의 엑셀 기능은 현재 속도 * 1.1, 테슬라의 엑셀 기능은 현재 속도 * 1.12 등의 방식으로 다를 수 있다.
    - 자동차를 역할과 구현을 나눈 이유는, 운전자를 위해서다.
      - 클라이언트에게 영향을 주지 않고 새로운 기능을 제공할 수 있다.
      
- 역할과 구현을 분리
  - 역할과 구현으로 구분하면, 세상이 단순해지고, 유연해지며, 변경도 편리해진다.
  - 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
    - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
    - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
  - 자바 언어의 다형성을 활용
    - 역할-> 인터페이스, 구현-> 인터페이스를 구현한 클래스, 구현 객체
  - 객체를 설계할 때 역할과 구현을 명확히 분리
  - 객체 설계시 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

- 객체의 협력이라는 관계부터 생각
  - 혼자있는 객체는 없다.
  - 클라이언트: 요청, 서버: 응답
  - 수 많은 객체 클라이언트와 객체 서버는 서로 협력관계를 갖는다.

- 자바 언어의 다형성
  - 예제
    - MemberService에서 interface인 MemberRepository save() 호출하면,
    - MemberService에서 MemberRepository를 MemoryMemberRepository로 생성 또는 주입하였으면, MemoryMemberRepository의 save()가 호출
    - MemberService에서 MemberRepository를 JdbcMemberRepository로 생성 또는 주입하였으면, JdbcMemberRepository의 save()가 호출
  - 오버라이딩
  - 물론, 클래스 상속 관게도 다형성, 오버라이딩 적용가능

- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
  - 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관게에서 시작해야 한다.
  - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

- 한계
  - 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - 즉, 인터페이스를 안정적으로 잘 설계하는 것이 중요

- 스프링과 객체 지향
  - 다형성이 가장 중요하다.
  - 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
  - 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 주 있도록 지원한다.
  - 스프링을 사용하면 마치 레고 블록을 조립하듯이 구현을 편리하게 변경할 수 있다.

#### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리했다.
  - SRP: 단일 책임 원칙, Single Responsibility Principle
  - OCP: 개방-폐쇄 원칙, Open/Closed Principle
  - LSP: 리스코프 치원 원칙, Liskov Substitution Principle
  - ISP: 인터페이스 분리 원칙, Interface Segregation Principle
  - DIP: 의존관계 역정 원칙, Dependency Inversion Principle

- SRP
  - 단일 책임 원칙, Single Responsibility Principle
  - 한 클래스는 하나의 책임만 가져야 한다.
  - 하나의 책임이라는 것은 모호하다.
    - 크고 작을 수 있다.
    - 문맥과 상황에 따라 다르다.
    - 범위를 적절하게 하는 것이 좋다. 너무 잘게 쪼개질 수도 있고, 책임이 너무 많아질 수 있다.
  - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따르는 것
  - 예시, UI 변경, 객체의 생성과 사용을 분리

- OCP
  - 개방-폐쇄 원칙, Open/Closed Principle
  - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 다형성을 활용해보자
    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
    - 역할과 구현의 분리

  - 예제
    - MemberService에서 MemberRepository의 save() 호출
      - MemoryMemberRepository와 JdbcMemberRepository가 있다.
      ```java
      // MemberRepository m = new MemoryMemberRepository(); // 기존 코드
      MemberRepository repository = new JdbcMemberRepository();
      ```
      - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
      - 분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.
    - 해결책
      - 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
      - 
- LSP
  - 리스코프 치원 원칙, Liskov Substitution Principle
  - 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 하는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
  - 단순히 컴파일에 성공하는 것을 넘어서는 이야기
  - 예제
    - 자동차 인터페이스의 엑셀은 앞으로 가는 기능, 뒤로 가게 구현하면 LSP 위반. 느리더라도 앞으로 가야 한다.    

- ISP
  - 인터페이스 분리 원칙, Interface Segregation Principle
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
    - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
  - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- DIP
  - 의존관계 역정 원칙, Dependency Inversion Principle
  - "개발자는 추상화에 의존해야지, 구체화에 의존하면 안된다" 는 원칙이 의존성 주입을 다르는 방법 중 하나다.
  - 구현 클래스에 의존하지 말고, 인터페이스에 의존하자는 뜻
  - 역할(Role)에 의존하게 해야 한다는 것과 같다.
    - 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
    - 구현체에 의존하게 되면 변경이 어려워진다.
  - 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 의존하고 있다.
    ```java
    MemberRepository repository = new MemoryMemberRepository();
    ```
    - DIP 위반

- 정리
  - 객체 지향의 핵심은 다형성
  - 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
  - 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
  - 다형성 만으로는 OCP, DIP를 지킬 수 없다.
  - 뭔가 더 필요하다...

#### 객체 지향 설계와 스프링

- DI, DI Container
  - DI: Dependency Injection - 의존 관계, 의존성 주입
  - Spring은 DI 컨테이너 제공
  - 이를 활용하여 다형성 + OCP, DIP를 활용할 수 있다.
    - 클라이언트 코드의 변경 없이 기능 확장 가능

- 정리
  - 모든 설게에 역할과 구현을 분리하자.
  - 애플리케이션 설계도 유연하고 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계
  - 이상적으로 모든 설계에 인터페이스를 부여하자.
    - 하지만, 인터페이스를 도입하면 추상화라는 비용이 발생
    - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용
    - 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

- 출처: 인프런 김영한님 강연_스프링 핵심 원리 - 기본편  
