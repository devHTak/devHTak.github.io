---
layout: post
title: SQL Tuning. index 기본 및 튜닝
summary: SQL Tuning
author: devhtak
date: '2021-10-24 21:41:00 +0900'
category: SQL
---

#### 인덱스 구조 및 탐색

- 미리보는 인덱스 튜닝

  - 데이터베이스 테이블에서 데이터를 찾는 방법 2가지
    - 테이블 전체 스캔
    - 인덱스 이용

  - 인덱스 튜닝의 핵심요소
    - 인덱스 스캔 효율화 튜닝
      - 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것
    - 테이블 랜덤 액세스 최소화 튜닝
      - 테이블 액세스 횟수를 줄이는 방법
      - 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용

    ![image](https://user-images.githubusercontent.com/42403023/140036433-ca7cf8ec-0d6d-4f98-a6af-f9349a60c5d5.png)

    - 인덱스 스캔 효율화보다 테이블 랜덤 액세스 최소화 튜닝이 성능 향상에 더 좋다.
    - SQL 튜닝은 랜덤 I/O를 줄이는 것이 중요하다
    - index scan(Sequential 액세스)
      - 레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽어 나가는 방식
      - 인덱스 리프 블록에 위치한 모든 레코드는 포인터를 따라 논리적으로 연결돼 있고, 이 포인터를 따라 스캔하는 것은 Sequential 액세스 방식
    - Table random access(Random access)
      - Random 액세스는 레코드간 논리적, 물리적인 순서를 따르지 않고, 한 건을 읽기 위해 한 블록씩 접근하는 방식

- 인덱스 구조
  - B* Tree
    
    ![image](https://user-images.githubusercontent.com/42403023/140037570-a8c21e4b-6bf1-4ee5-8640-b50bd1b1a654.png)

    - 블록에 있는 레코드가 가리키는 하위 블록에는 해당 값에 대한 범위로 값을 갖는 블록이 존재한다.
    - 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값(rowid)을 갖는다
      - rowid: 데이터 블록 주소 + row 번호
      - 데이터 블록 주소: 데이터 파일 번호 + 블록 번호
      - 블록 번호: 데이터 파일 내에서 부여한 상대적 순번
      - 로우 번호: 블록 내 순번

    - 인덱스 탐색 과정
      - 수직적 탐색: 인덱스 스캔 시작지점을 찾는 과정
        - 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정으로 인덱스 스캔 시작지점을 찾는 과정
        - 루트 블록에서 시작하여 하위 블록에 대한 주소값과 범위에 대한 기준으로 리프 블록까지 수직적 탐색을 하는 과정
        - 범위와 같은 기준을 통해 조건을 만족하는 첫번째 레코드를 만날 수 있다.

      - 수평적 탐색: 데이터를 찾는 과정
        - 데이터를 찾는 과정
        - 트리의 구성은 양방향 연결리스트이기 때문에 앞뒤 블록에 대한 주소값을 갖기 때문에 수평적 탐색이 가능하다
        - 수평적 탐색 이유
          - 조건절을 만족하는 데이터를 모두 찾기 위해서
          - 테이블 스캔을 위한 rowid를 얻기 위해서

#### 인덱스 기본 사용법

- 인덱스를 사용한다는 것
  - index 기본 사용법은 range scan을 의미하며 index 확장 기능은 range scan 외에 다양한 스캔 방식을 말한다.
  - index range scan 방식
    - 스캔 시작점을 찾아 시작점부터 스캔을 하며 중간에 멈추는 것을 말한다.
    - 예시) 사전에서 글로벌이란 단어를 찾는다면 ㄱ 이라는 시작 지점으로 부터 찾을 것이다.
  - index full scan 방식
    - 인덱스를 사용할 수 있지만, 스캔 시작점을 찾을 수 없고, 멈출 수도 없이 리프 블록 전체를 스캔해야 되는 것
    - 예시) 사전에서 '인덱스'가 포함된 단어를 찾는다면 시작점을 찾을 수 없고, 멈출 수 없고 색인 전체를 스캔해야 한다.
  - index range scan 을 사용하지 못하는 경우
    ```
    - SUBSTR(BIRTHDAY, 2, 5) = '05' // 생년월일(YYYYMMDD)이 index이지만 생년 월일이 5월인 학생을 찾을 때
    - NVL(ORD_COUNT, 0) < 100 // NULL값이 0으로 치환한 값
    - NAME LIKE '%현%' // LIKE 연산으로 중간값을 찾는 경우
    - PHONE_NUMBER = :phoneNumber OR CUSTOMER_NAME = :customerName // OR 연산에 경우 어느 한 시작점을 찾을 수 없다
     // OR 연산, IN 연산에 경우 Index Full Scan 이 발생하기 때문에 UNION ALL로 해결할 수 있다
    ```


#### 참고

- 조시형 저자의 친절한 SQL 튜닝 교재
- sequential & randomaccess: https://m.cafe.daum.net/Oracle-/DHl0/94?listURI=%2FOracle-%2F_rec
