---
layout: post
title: SQL Tuning. index 기본
summary: SQL Tuning
author: devhtak
date: '2021-11-03 21:41:00 +0900'
category: SQL
---

#### 테이블 액세스 최소화

- 인덱스를 통해 조회하는 것이 table full scan보다 느릴 때가 있다.
  - 테이블 랜덤 액세스
    - 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까
      - 물리적 주소: 데이터파일 번호, 오브젝트 번호, 블록 번호와 같은 물리적 요소로 구성되어 있다.
      - 논리적 주소: 물리적(포인터)으로 직접 연결되어 있지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있다
      - 그래서 논리적 주소에 더 가깝다
    - 메인 메모리 DB와 비교
      - 메인 메모리 DB는 모든 데이터를 메인 메모리에 로드해 놓고 메모리를 통해서만 I/O 하는 DB
      - 오라클은 데이터 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되는 데 이럴 때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조
        - 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(DBA, Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다
    - I/O 메커니즘
      - I/O 성능을 높이기 위해 버퍼 캐시를 활용하기 때문에 버퍼 캐시를 찾은 후 데이터를 찾지 못하는 경우 디스크를 찾는 과정을 거친다 
      - 해싱 알고리즘을 통해 버퍼 헤더를 찾고, 헤더 내에서 얻은 포인터로 버퍼 블록을 찾는다.

  - 인덱스 클러스터링 팩터
    - 클러스터링 팩터(Clustering Factor)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
    - CF가 좋은 컬럼에 생성한 인덱스는 그만큼 스캔하는 부분이 작기 때문에 좋은 효율을 갖게 된다.
      - 테이블 액세스량에 비해 블록 I/O가 적게 발생하는 것

  - 인덱스 손익분기점
    - Index Range Scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 시점을 인덱스 손익분기점이라고 부른다
    - Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
    - Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID는 Single Block I/O 이다

- 인덱스 컬럼 추가
  - 가장 일반적으로 사용하는 튜닝 기법
  - 인덱스를 계속 추가하다 보면 테이블 마다 인덱스가 수십 개씩 달려 인덱스 관리 비용에 증가, DML 부하에 따른 트랜잭션 성능 저하가 발생할 수 있다.
  - 테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 성능 효과를 볼 수 있다.
  
- 인덱스만 읽고 처리
  - Covered 인덱스
    ```
    SELECT 부서번호, SSUM(수량)
    FROM 부서
    WHERE 부서번호 LIKE '12%'
    GROUP BY 부서번호
    ```
    - index가 부서번호인 경우 12로 시작하는  index leaf node를 찾고 해당하는 Table Access한다.
    - 해당에 경우 처럼 Table Access 한만큼 데이터를 가져오는 경우에는 index에 문제가 아닌 일의 양이 많은 것
    - 이럴 때에는 인덱스만 읽어서 처리하도록 사용하는 컬럼을 모두 index로 하는 것을 covered index라고 하며, 이런 경우 성능이 향상된다.
    - 하지만, 사용하는 컬럼이 많으면 실제 적용하기 어렵다
    
  - Include index
    - 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
      ```
      CREATE INDEX emp_x01 ON EMP (DEPTNO) INCLUDE(SAL)
      CREATE INDEX emp_x02 ON EMP (DEPTNO, SAL)
      ```
      - emp_x01은 모든 노드들은 DEPTNO가 있으며 리프 레벨에 노드에는 SAL 컬럼과 함께 저장된다.
      - emp_x02 는 DEPTNO와 SAL 컬럼 모두 루트와 브랜치 블록에 저장한다. 
    - include index는 Table Random Access 횟수를 줄이는 용도로만 사용한다
  
- 인덱스 구조 테이블(Index-Organized Table)
  
  ![image](https://user-images.githubusercontent.com/42403023/141116443-f888d7f6-e5b5-4206-9957-32f44f232dc8.png)

  ```
  CREATE TABLE INDEX_ORT_T(A NUMBER, B VARCHAR(10), CONTRAINT INDEX_ORG_T_PK PRIMARY KEY(A))
  ORGANIZATION INDEX;
  ```
  - Rand Access가 발생하지 않도록 Table을 index 구조로 생성하는 방법
  - index leaf block이 곧 data block이 되며 정렬 상태를 유지하며 데이터를 입력한다.
  - Clustering Factor를 좋게 만드는 방법 중 하나

- 클러스터 테이블
  - 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.
  - 인덱스 클러스터 테이블
    - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.
    - 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
    - 여러 테이블 레코드를 같은 블록에 저장할 수도 있다.
    - 인덱스 클러스터 테이블 구성
      ```
      -- 먼저 아래와 같이 클러스터를 생성한다.
      create cluster c_dept# ( deptno number(2) ) index ;

      -- 클러스터에 테이블을 담기 전에 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다. 
      -- 클러스터 인덱스는 데이터 검색 용도로 사용할 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 때문이다.
      create index c_dept#_idx on cluster c_dept#;

      -- 클러스터 인덱스를 만들었으면 아래와 같이 클러스터 테이블을 생성한다.
      create table dept (
        deptno number(2)    not null
      , dname  varchar2(4)  not null
      , loc    varchar2(13) )
      cluster c_dept#( deptno );
      ```
    - 클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다르다.
    - 클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다.
    - 이런 구조적 특성 떄문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩 밖에 발생하지 않는다.
    - 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 게 핵심 원리다.

  - 해시 클러스터 테이블
    - 해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.
    - 해시 클러스터 테이블 구성
      ```
      -- 먼저 클러스터를 생성하고 위에서 했던 것처럼 클러스터 테이블을 생성한다.
      create cluster c_dept# ( deptno number(2) ) hashkeys 4 ;
      ```

#### 부분범위 처리 활용

- 부분 범위 처리
  - 전체 쿼리 결과 집합을 쉼없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것 
  - DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다.
    - 전체 결과집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 멈춰 기다린다.
    - 전체 데이터를 보내는 것이 아닌 일정량만 보낸 후 CPU를 OS에 반환하고 대기 큐에서 대기하다 Fetch Call을 받으면 대기 큐에서 나와 그 다음 데이터를 전송한다.
  
  - 정렬 조건이 있을 때 부분범위 처리
    ```
    SELECT NAME 
    FROM BIG_TABLE
    ORDER BY CREATED
    ```
    - CREATED 컬럼으로 정렬하게 되면 부분범위 처리가 가능할까?
      - 모든 데이터를 읽은 후 CREATED 순으로 정렬을 마친 후 클라이언트에게 데이터를 전송하기 때문에 전체범위처리다.
      - 만약 CREATED 컬럼이 선두 index에 경우 부분범위 처리가 가능하다

- 웹 환경에서 부분범위 처리
  - 웹 환경에서는 주로 목록을 조회하는 경우가 발생하기 때문에 이럴 때에는 항상 정렬된 상태를 유지하는 인덱스를 사용하면 정렬 작업을 생략하고 앞쪽 일부 데이터를 빠르게 보여줄 수 있다.
  - 예시
    ```
    SELECT 게시글ID, 제목, 작성자, 등록일시
    FROM 게시판
    WHERE 게시판구분코드='A'
    ORDER BY 등록일시 DESC
    ```
    - 만약 index를 \[게시판구분코드, 등록일시] 로 구성하지 않는다면
      - Order를 생략하지 않는다면 게시판구분코드가 A인 데이터를 등록일시 기준으로 정렬한 후 일정 부분만 가져오기 때문에 의미가 없다.
    - index를 \[게시판구분코드, 등록일시] 로 구성한다면
      - 정렬할 필요가 없기 때문에 게시판구분코드가 A인 데이터 전체를 읽지 않고 정해진 크기만 읽고 처리할 수 있다.

- 참고. Batch IO
  - 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능
  - 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
  
#### 인덱스 스캔 활용화

```
참고) 옵티마이저의 비용 계산 원리
비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
    = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 
      + 인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수
      + 테이블 액세스 과정에 읽는 블록 수
```
- 액세스 조건과 필터 조건
  - 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절로 인덱스 시작점을 찾기 위한 수직적 탐색과 종료지점까지 스캔하는 수평적 스캔을 결정한다.
  - 인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절
  - 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다
  - 비교연산자 종류와 컬럼 순서에 따른 군집성
    - 테이블과 달리 인덱스는 데이터가 정렬되어 있기 때문에 '=' 연산에 경우 모여있는 레코드를 갖게 된다
    ```
    /* 조건절 1 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4='a'
    /* 조건절 2 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4 >= 'a'
    /* 조건절 3 */
    WHERE C1 = 1 AND C2='A' AND C3 between '가' AND '다' AND C4='a'
    /* 조건절 4 */
    WHERE C1 = 1 AND C2 <= 'B' AND C3='나' AND C4 between 'a' and 'b'
    /* 조건절 5 */
    WHERE C1 between 1 and 4 AND C2='A' AND C3='나' AND C4='a'
    ```
    - 조건절 1. 선행조건들이 모두 정렬되어 있다.
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 2. 맨 마지막 조건만 범위검색 조건으로일 때에도 레코드가 서로 모여 있다
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 3. 중간에 데이터가 범위 검색 조건에 경우 C1~C3까지는 모여있지만 C4 조건에 해당하는 데이터는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2, C3
      - 인덱스 필터 조건: C4
    - 조건절 4. C1, C2 조건에 해당하는 레코드는 모여있지만, C3, C4는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2
      - 인덱스 필터 조건: C3, C4
    - 조건절 5.
      - 인덱스 액세스 조건: C1
      - 인덱스 필터 조건: C2, C3, C4
  
- 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
  - 인덱스 선행 컬럼 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, 인덱스는 조건을 만족하는 레코드가 모여있기 때문이다.
  - 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

- BETWEEN을 IN-List로 전환
  - BETWEEN 조건을 IN 조건으로 전환
    ```
    SELECT *
    FROM 매물아파트매매
    WHERE 인터넷매물 in ('1', '2', '3')
    AND   아파트시세코드='A12341234'
    AND   평형 = '59'
    ORDER BY 입력일 DESC;
    ------------------------------------------------------------------
    |ID|Operation                   |NAME            |ROWS|BYTES|COST|
    |0|SELECT STATEMENT             |                |    |     |6   |
    |1| INLIST ITERATOR             |                |    |     |    |
    |2|  TABLE ACCESS BY INDEX ROWID|매물아파트매매   |3   |37   |6   |
    |3|   INDEX RANGE SCAN          |매물아파트매매_pk|3   |     |5   |
    ------------------------------------------------------------------
    ```
    - BETWEEN에 경우 1 ~3 에 대한 레코드를 전체 스캔한다.
    - 하지만 IN 조건에 경우 실행계획이 INLIST ITERATOR로 발생하는 것은 인터넷 매물이 1인 경우 + 2인 경우 + 3인 경우에 대한 수직적 탐색이 3번 일어나는 것 
    - UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하는 것과 동일한 성능을 얻는다.
  - BETWEEN 조건을 IN-List 조건으로 전환할 때 주의 사항
    - 개수가 많으면 수직적 탐색이 많이 발생하기 때문에 IN-List 개수가 많지 않아야 한다.
    - 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.
      - Sequential Scan이 성능이 더 좋을 수 있게 된다

- Index Skip Scan 활용
  - 선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.
  - 예시
    ```
    SELECT /*+ index(t 월별고객별판매집계_idx2) */
      count(*)
    FROM 월별고객별판매집계 t
    WHERE 판매구분 = 'A'
    AND   판매월 between '201801' AND '201812'
    ```
    - 만약 데이터가 서로 멀리 떨어져 있을 때 between을 in으로 변경해주어도 되지만 너무 조건이 많아 수직적 탐색 양이 많아진다
      - 판매월 IN ('201801', '201802', .... '201811', '201812');
    - 이런 경우 index skip scan을 사용하면 좋은 성능을 가져올 수 있다.
      - /* index_ss(t 월별고객별판매집계_idx2) */
  
- IN 조건은 '='이 아니다. 
  - IN 조건은 '=' 조건이 아니기 때문에 인덱스를 어떻게 구성하느냐에 따라 성능도 달라질 수 있다.
  - IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면, IN 조건은 필터 조건이다.
  - IN 조건을 '=' 조건으로 만들기 위해, 즉 액세스 조건으로 만들기 위해 IN-List Iterator 방식으로 푸는 것이 항상 효과적인 것은 아니다.
  - NUM_INDEX_KEYS 힌트 활용
    - /*+ num_index_keys(a 고객별가입상품_X1 1) */는 세 번째 인자 값의 인덱스 컬럼까지만 액세스 조건으로 사용하라는 의미다.
  

#### 인덱스 설계

#### 참고

- 조시형 저자의 개발자를 위한 SQL 튜닝 입문서 친절한 SQL 튜닝
  - https://url.kr/fjm9l2
