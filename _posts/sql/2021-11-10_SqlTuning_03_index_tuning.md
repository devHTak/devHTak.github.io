---
layout: post
title: SQL Tuning. index 기본
summary: SQL Tuning
author: devhtak
date: '2021-11-03 21:41:00 +0900'
category: SQL
---

#### 테이블 액세스 최소화

- 인덱스를 통해 조회하는 것이 table full scan보다 느릴 때가 있다.
  - 테이블 랜덤 액세스
    - 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까
      - 물리적 주소: 데이터파일 번호, 오브젝트 번호, 블록 번호와 같은 물리적 요소로 구성되어 있다.
      - 논리적 주소: 물리적(포인터)으로 직접 연결되어 있지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있다
      - 그래서 논리적 주소에 더 가깝다
    - 메인 메모리 DB와 비교
      - 메인 메모리 DB는 모든 데이터를 메인 메모리에 로드해 놓고 메모리를 통해서만 I/O 하는 DB
      - 오라클은 데이터 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되는 데 이럴 때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조
        - 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(DBA, Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다
    - I/O 메커니즘
      - I/O 성능을 높이기 위해 버퍼 캐시를 활용하기 때문에 버퍼 캐시를 찾은 후 데이터를 찾지 못하는 경우 디스크를 찾는 과정을 거친다 
      - 해싱 알고리즘을 통해 버퍼 헤더를 찾고, 헤더 내에서 얻은 포인터로 버퍼 블록을 찾는다.

  - 인덱스 클러스터링 팩터
    - 클러스터링 팩터(Clustering Factor)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
    - CF가 좋은 컬럼에 생성한 인덱스는 그만큼 스캔하는 부분이 작기 때문에 좋은 효율을 갖게 된다.
      - 테이블 액세스량에 비해 블록 I/O가 적게 발생하는 것

  - 인덱스 손익분기점
    - Index Range Scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 시점을 인덱스 손익분기점이라고 부른다
    - Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
    - Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID는 Single Block I/O 이다

- 인덱스 컬럼 추가
  - 가장 일반적으로 사용하는 튜닝 기법
  - 인덱스를 계속 추가하다 보면 테이블 마다 인덱스가 수십 개씩 달려 인덱스 관리 비용에 증가, DML 부하에 따른 트랜잭션 성능 저하가 발생할 수 있다.
  - 테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 성능 효과를 볼 수 있다.
  
- 인덱스만 읽고 처리
  - Covered 인덱스
    ```
    SELECT 부서번호, SSUM(수량)
    FROM 부서
    WHERE 부서번호 LIKE '12%'
    GROUP BY 부서번호
    ```
    - index가 부서번호인 경우 12로 시작하는  index leaf node를 찾고 해당하는 Table Access한다.
    - 해당에 경우 처럼 Table Access 한만큼 데이터를 가져오는 경우에는 index에 문제가 아닌 일의 양이 많은 것
    - 이럴 때에는 인덱스만 읽어서 처리하도록 사용하는 컬럼을 모두 index로 하는 것을 covered index라고 하며, 이런 경우 성능이 향상된다.
    - 하지만, 사용하는 컬럼이 많으면 실제 적용하기 어렵다
    
  - Include index
    - 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
      ```
      CREATE INDEX emp_x01 ON EMP (DEPTNO) INCLUDE(SAL)
      CREATE INDEX emp_x02 ON EMP (DEPTNO, SAL)
      ```
      - emp_x01은 모든 노드들은 DEPTNO가 있으며 리프 레벨에 노드에는 SAL 컬럼과 함께 저장된다.
      - emp_x02 는 DEPTNO와 SAL 컬럼 모두 루트와 브랜치 블록에 저장한다. 
    - include index는 Table Random Access 횟수를 줄이는 용도로만 사용한다
  
- 인덱스 구조 테이블(Index-Organized Table)
  
  ![image](https://user-images.githubusercontent.com/42403023/141116443-f888d7f6-e5b5-4206-9957-32f44f232dc8.png)

  ```
  CREATE TABLE INDEX_ORT_T(A NUMBER, B VARCHAR(10), CONTRAINT INDEX_ORG_T_PK PRIMARY KEY(A))
  ORGANIZATION INDEX;
  ```
  - Rand Access가 발생하지 않도록 Table을 index 구조로 생성하는 방법
  - index leaf block이 곧 data block이 되며 정렬 상태를 유지하며 데이터를 입력한다.
  - Clustering Factor를 좋게 만드는 방법 중 하나

- 클러스터 테이블
  - 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.
  - 인덱스 클러스터 테이블
    - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.
    - 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
    - 여러 테이블 레코드를 같은 블록에 저장할 수도 있다.
    - 인덱스 클러스터 테이블 구성
      ```
      -- 먼저 아래와 같이 클러스터를 생성한다.
      create cluster c_dept# ( deptno number(2) ) index ;

      -- 클러스터에 테이블을 담기 전에 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다. 
      -- 클러스터 인덱스는 데이터 검색 용도로 사용할 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 때문이다.
      create index c_dept#_idx on cluster c_dept#;

      -- 클러스터 인덱스를 만들었으면 아래와 같이 클러스터 테이블을 생성한다.
      create table dept (
        deptno number(2)    not null
      , dname  varchar2(4)  not null
      , loc    varchar2(13) )
      cluster c_dept#( deptno );
      ```
    - 클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다르다.
    - 클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다.
    - 이런 구조적 특성 떄문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩 밖에 발생하지 않는다.
    - 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 게 핵심 원리다.

  - 해시 클러스터 테이블
    - 해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.
    - 해시 클러스터 테이블 구성
      ```
      -- 먼저 클러스터를 생성하고 위에서 했던 것처럼 클러스터 테이블을 생성한다.
      create cluster c_dept# ( deptno number(2) ) hashkeys 4 ;
      ```

#### 부분범위 처리 활용

- 부분 범위 처리
  - 전체 쿼리 결과 집합을 쉼없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것 
  - DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다.
    - 전체 결과집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 멈춰 기다린다.
    - 전체 데이터를 보내는 것이 아닌 일정량만 보낸 후 CPU를 OS에 반환하고 대기 큐에서 대기하다 Fetch Call을 받으면 대기 큐에서 나와 그 다음 데이터를 전송한다.
  
  - 정렬 조건이 있을 때 부분범위 처리
    ```
    SELECT NAME 
    FROM BIG_TABLE
    ORDER BY CREATED
    ```
    - CREATED 컬럼으로 정렬하게 되면 부분범위 처리가 가능할까?
      - 모든 데이터를 읽은 후 CREATED 순으로 정렬을 마친 후 클라이언트에게 데이터를 전송하기 때문에 전체범위처리다.
      - 만약 CREATED 컬럼이 선두 index에 경우 부분범위 처리가 가능하다

- 웹 환경에서 부분범위 처리
  - 웹 환경에서는 주로 목록을 조회하는 경우가 발생하기 때문에 이럴 때에는 항상 정렬된 상태를 유지하는 인덱스를 사용하면 정렬 작업을 생략하고 앞쪽 일부 데이터를 빠르게 보여줄 수 있다.
  - 예시
    ```
    SELECT 게시글ID, 제목, 작성자, 등록일시
    FROM 게시판
    WHERE 게시판구분코드='A'
    ORDER BY 등록일시 DESC
    ```
    - 만약 index를 \[게시판구분코드, 등록일시] 로 구성하지 않는다면
      - Order를 생략하지 않는다면 게시판구분코드가 A인 데이터를 등록일시 기준으로 정렬한 후 일정 부분만 가져오기 때문에 의미가 없다.
    - index를 \[게시판구분코드, 등록일시] 로 구성한다면
      - 정렬할 필요가 없기 때문에 게시판구분코드가 A인 데이터 전체를 읽지 않고 정해진 크기만 읽고 처리할 수 있다.

- 참고. Batch IO
  - 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능
  - 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
  
#### 인덱스 스캔 활용화

```
참고) 옵티마이저의 비용 계산 원리
비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
    = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 
      + 인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수
      + 테이블 액세스 과정에 읽는 블록 수
```
- 액세스 조건과 필터 조건
  - 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절로 인덱스 시작점을 찾기 위한 수직적 탐색과 종료지점까지 스캔하는 수평적 스캔을 결정한다.
  - 인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절
  - 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다
  - 비교연산자 종류와 컬럼 순서에 따른 군집성
    - 테이블과 달리 인덱스는 데이터가 정렬되어 있기 때문에 '=' 연산에 경우 모여있는 레코드를 갖게 된다
    ```
    /* 조건절 1 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4='a'
    /* 조건절 2 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4 >= 'a'
    /* 조건절 3 */
    WHERE C1 = 1 AND C2='A' AND C3 between '가' AND '다' AND C4='a'
    /* 조건절 4 */
    WHERE C1 = 1 AND C2 <= 'B' AND C3='나' AND C4 between 'a' and 'b'
    /* 조건절 5 */
    WHERE C1 between 1 and 4 AND C2='A' AND C3='나' AND C4='a'
    ```
    - 조건절 1. 선행조건들이 모두 정렬되어 있다.
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 2. 맨 마지막 조건만 범위검색 조건으로일 때에도 레코드가 서로 모여 있다
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 3. 중간에 데이터가 범위 검색 조건에 경우 C1~C3까지는 모여있지만 C4 조건에 해당하는 데이터는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2, C3
      - 인덱스 필터 조건: C4
    - 조건절 4. C1, C2 조건에 해당하는 레코드는 모여있지만, C3, C4는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2
      - 인덱스 필터 조건: C3, C4
    - 조건절 5.
      - 인덱스 액세스 조건: C1
      - 인덱스 필터 조건: C2, C3, C4
  
- 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
  - 인덱스 선행 컬럼 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, 인덱스는 조건을 만족하는 레코드가 모여있기 때문이다.
  - 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

- BETWEEN을 IN-List로 전환
  - BETWEEN 조건을 IN 조건으로 전환
    ```
    SELECT *
    FROM 매물아파트매매
    WHERE 인터넷매물 in ('1', '2', '3')
    AND   아파트시세코드='A12341234'
    AND   평형 = '59'
    ORDER BY 입력일 DESC;
    ------------------------------------------------------------------
    |ID|Operation                   |NAME            |ROWS|BYTES|COST|
    |0|SELECT STATEMENT             |                |    |     |6   |
    |1| INLIST ITERATOR             |                |    |     |    |
    |2|  TABLE ACCESS BY INDEX ROWID|매물아파트매매   |3   |37   |6   |
    |3|   INDEX RANGE SCAN          |매물아파트매매_pk|3   |     |5   |
    ------------------------------------------------------------------
    ```
    - BETWEEN에 경우 1 ~3 에 대한 레코드를 전체 스캔한다.
    - 하지만 IN 조건에 경우 실행계획이 INLIST ITERATOR로 발생하는 것은 인터넷 매물이 1인 경우 + 2인 경우 + 3인 경우에 대한 수직적 탐색이 3번 일어나는 것 
    - UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '=' 조건으로 검색하는 것과 동일한 성능을 얻는다.
  - BETWEEN 조건을 IN-List 조건으로 전환할 때 주의 사항
    - 개수가 많으면 수직적 탐색이 많이 발생하기 때문에 IN-List 개수가 많지 않아야 한다.
    - 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.
      - Sequential Scan이 성능이 더 좋을 수 있게 된다

- Index Skip Scan 활용
  - 선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.
  - 예시
    ```
    SELECT /*+ index(t 월별고객별판매집계_idx2) */
      count(*)
    FROM 월별고객별판매집계 t
    WHERE 판매구분 = 'A'
    AND   판매월 between '201801' AND '201812'
    ```
    - 만약 데이터가 서로 멀리 떨어져 있을 때 between을 in으로 변경해주어도 되지만 너무 조건이 많아 수직적 탐색 양이 많아진다
      - 판매월 IN ('201801', '201802', .... '201811', '201812');
    - 이런 경우 index skip scan을 사용하면 좋은 성능을 가져올 수 있다.
      - /* index_ss(t 월별고객별판매집계_idx2) */
  
- IN 조건은 '='이 아니다. 
  - IN 조건은 '=' 조건이 아니기 때문에 인덱스를 어떻게 구성하느냐에 따라 성능도 달라질 수 있다.
    ```
    SELECT *
    FROM 고객별가입상품
    WHERE 고객번호 = :custNo
    AND   상품ID in ('NG0037', 'NH0041', 'NH0050')
    ```
  - 만약 \[상품ID + 고객번호] 로 이루어져 있는 경우 노드에 데이터가 상품ID로 나누어져 있기 때문에 sequential scan에 범위가 넓어진다.
    - IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면, IN 조건은 필터 조건이다.
  - 해당 index가 \[고객번호 + 상품ID] 로 되어 있는 경우에는 index에 대한 스캔이 한번 이뤄진다.
    - IN 조건을 '=' 조건으로 만들기 위해, 즉 액세스 조건으로 만들기 위해 IN-List Iterator 방식으로 푸는 것이 항상 효과적인 것은 아니다.
  - NUM_INDEX_KEYS 힌트 활용
    - IN-List 를 액세스 조건 또는 필터 조건으로 유도하는 방법
    ```
    SELECT * /*+ num_index_keys(a 고객별가입상품_X1 1) */
    FROM 고객별가입상품 a
    WHERE 고객번호 = :custNo
    AND   상품ID in ('NG0037', 'NH0041', 'NH0050')
    ```
    - /*+ num_index_keys(a 고객별가입상품_X1 1) */는 세 번째 인자 값의 인덱스 컬럼까지만 액세스 조건으로 사용하라는 의미다.
  
- BETWEEN과 LIKE 스캔 범위 비교
  - LIKE와 BETWEEN은 둘 다 범위검색 조건으로 앞에서 설명한 범위검색 조건을 사용할 때의 비효율 원리가 똑같이 적용한다

  ![image](https://user-images.githubusercontent.com/42403023/141430484-3317c8f8-2a38-401f-bd4b-d3c39a393102.png)

  - 다만, BETWEEN이 LIKE 보다 효율이 약간 좋다

- 다양한 옵션 조건 처리 방식의 장단점 비교
  - OR 조건 활용
    ```
    AND (:custId IS NULL OR CUST_ID = :custId)
    ```
    - 옵티마이저에 의한 OR Expansaion 쿼리 변환은 기본적으로 작동하지 않기 때문에 인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해서는 안된다.
    - OR 조건
      - 인덱스 액세스 조건으로 사용 불가
      - 인덱스 필터 조건으로 사용 불가
      - 테이블 액세스 조건으로만 사용 가능
      
  - LIKE/BETWEEN 조건 활용
    ```
    AND CUST_ID LIKE :custId || '%'
    ```
    - 사용 전 점검 사항
      - 인덱스 선두 컬럼인 경우 성능에 큰 영향을 준다
      - NULL 허용 컬럼인 경우 ( NULL LIKE '%') 이 되어 NULL인 데이터가 누락된다.
      - 숫자형 컬럼인 경우 자동 형변환이 발생하여 CUST_ID가 필터링 된다
      - 가변 길이 컬럼인 경우 예기치 않은 데이터가 조회될 수 있다
      
  - UNION ALL 활용
    - 성능적으로 가장 최적으로 사용된다.
    - 단점으로는 코드량이 길어지며 가독성이 떨어진다.
    
  - NVL/DECODE 활용
    - UNION ALL 보다 보기 간편하지만 같은 성능을 낸다.
    - 하지만, NULL이 허용된 컬럼에 경우 NULL 데이터가 누락된다
    - 또한 OR Expansion이 일어날 수 있기 때문에 인덱스 구성컬럼이어도 필터조건이 될 수 있다.

- 함수호출부하 해소를 위한 인덱스 구성
  - PL/SQL 함수의 성능적 특성
  - 효과적인 인덱스 구성을 통한 함수호출 최소화

#### 인덱스 설계

- 인덱스 설계가 어려운 이유
  - 인덱스가 많으면 발생하는 문제
    - DML 성능 저하(-> TPS 저하): 신규 데이터 입력 또는 삭제할 때 모든 인덱스 레코드를 처리해야 한다
    - 데이터베이스 사이즈 증가(-> 디스크 공간 낭비)
    - 데이터베이스 관리 및 운영 비용 상승
  - 인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 크다.
    - 설계 단계에서 인덱스를 정교하게 설계해야 한다.
    
- 중요한 선택 기준
  - 효율이 좋은 Index Range Scan을 하기 위하여 아래 두가지 선택 기준을 고려하라
    - 조건절에 항상 사용하거나, 자주 사용하는 컬럼 선정
    - '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.(선두 컬럼)
    
- 스캔 효율성 이외의 판단 기준
  - 인덱스 스캔 효율성 이외 고려해야 할 판단 기준
    - 수행 빈도
    - 업무상 중요도
    - 클러스터링 팩터
    - 데이터 량
    - DML 부하(= 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
    - 저장 공간
    - 인덱스 관리 비용 등
  
- 공식을 초월한 전략적 설계
  - 조건절 패턴이 10개 있을 때, 열 개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최저 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다.
  - 예시
    - ‘가계약’ 테이블이 있다. 가계약 목록을 조회할 때 다양한 방식으로 조회한다. 
      - 드롭다운 리스트(콤보박스)에서 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택한다. 조건절 연산자는 ‘=’이다. 
      - 우측에 있는 네 개 일자/일시 중 하나를 선택한다. 조건절 연산자는 BETWEEN이다. 선택한 두 항목에 대한 값을 입력하고 조회 버튼을 누른다.
    - 인덱스 스캔 효율을 위해 ‘=’ 조건 컬럼을 앞에, BETWEEN 조건 컬럼을 뒤에 두려면 24개 인덱스가 필요하다. 
    - 설계) 일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식이다. 
      - X01 : 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
      - X02 : 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
      - X03 : 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사
      - X04 : 데이터생성일시 + 취급부서 + 취급지점 + 취급자 + 대리점설계사 + 대리점지사
    - 설계 핵심 포인트)
      - 첫째, 일자 조회구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다는 점이다.
      - 둘째, 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소라는 점이다.
    - 가계약은 주로 최근 3일 이내 데이터를 조회한다. 대개는 전일자로 조회하므로 인덱스 스캔량은 그리 많지 않다. 
      - 가끔 3일을 초과한 기간으로 조회할 수 있고, 어쩌다 한 달 치를 조회할 수도 있다.
      - 그렇더라도 불필요한 테이블 액세스는 전혀 발생하지 않도록 설계했으므로 사용자가 인내할 수 있는 수준의 성능은 낼 수 있다.
    - 사용자가 인내할 수 있는 수준의 인덱스 스캔 비효율이더라도 BETWEEN 조건 컬럼을 선두에 두고 설계하는 것은 좀 찜찜하다. 그런데도 이런 결정을 한 이유는 따로 있다. 
      - 가계약 데이블을 다양한 패턴으로 조회하지만, 그중 가장 많이 사용(85% 이상)하는 패턴은 입력자 ‘=’, 데이터생성일시 BETWEEN 조건이기 때문이다. 
      - 따라서 이 패턴에 최적의 스캔 효율을 제공하면, 다른 패턴에 다소 비효율이 있어도 업무에 크게 지장이 없다고 판단한 것이다.
    - 앞서 설계한 네 개 인덱스에 아래 인덱스를 하나 더 추가하자, (X04 인덱스에 입력자 컬럼은 누락된 것이 아니라 이 인덱스가 있어서 일부러 뺐다.)
      - X05 : 입력자 + 데이터생성일시
      
- 소트 연산을 생략하기 위한 컬럼 추가
  - 인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있기 때문에 조건절에 사용하지 않는 컬럼이라도 소트 연산을 생략할 목적으로 인덱스에 추가할 수 있다.
  - 예시
    ```
    SELECT *
    FROM 계약
    WHERE 취급지점ID = :trtBrchId
    AND   청약일자 BETWEEN :sbcpStartDt AND :sbcpEndDt
    AND   입력일자 >= TRUN(SYSDATE - 3)
    AND   계약상태코드 in (:ctrStatCd1, :ctrStatCd2, :ctrStatCd3)
    ORDER BY 청약일자, 입력자ID
    ```
    - 만약 sort를 생략하기 위해 index를 구성한다면 \[청약일자 + 입력자ID]로 구성
    - 성능 개선을 위해 '='조건절이고 상위 컬럼인 취급지점ID를 포함시킬 수 있다 (\[취급지점ID + 청약일자 + 입력자ID])
  - I/O 최소화와 소트 연산을 생략하기 위해서는 인덱스 구성을 아래와 같이 구성한다
    - '=' 연산자로 사용한 조건절 컬럼 선정
    - ORDER BY 절에 기술한 컬럼 추가
    - '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
  - 입력일자와 계약상태코드는 인덱스 추가해도 되고 안해도 된다
    - 해당 데이터가 적으면 인덱스에 추가하여 테이블 랜덤액세스를 줄이는 것이 좋다
    - 해당 데이터가 많은 경우 테이블 필터링과 큰차이가 없기 때문에 추가하지 않는 것이 좋다.
    
  - IN 조건은 '=' 이 아니다.
    - 예시
      ```
      SELECT *
      FROM 고객
      WHERE 거주지역 = '서울'
      AND   혈액형 IN ('A', 'O')
      ORDER BY 연력
      ```
      - IN 조건이 '=' 이 되기 위해서는 IN List Iterator가 되어야 한다
      ```
      SELECT *
      FROM (
          SELECT *
          FROM 고객
          WHERE 거주지역 = '서울'
          AND   혈액형 = 'A'

          UNION ALL

          SELECT *
          FROM 고객
          WHERE 거주지역 = '서울'
          AND   혈액형 = 'O'
      )
      ORDER BY 연령
      ```
      - \[거주지역 + 혈액형 + 연령], \[혈액형 + 거주지역 + 연령]
        - 혈액형이 연속된 블락에 저장되어 있지 않기 때문에 인덱스 구성을 SORTING 작업이 필요하다.
      - \[거주지역 + 연령 + 혈액형]
        - 연령에 대하여 먼저 sorting이 저장되어 있기 때문에 혈액형에 대한 IN List Iterator를 하여도 SORTING 작업이 필요 없다.
        
- 결합 인덱스 선택도
  - 선택도(Selectivity)와 카디널리티(Cardinality)
    - 선택도: 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율
    - 카디널리티: 선택도 * 총 레코드 수로 전체 데이터에 대한 중복 비율을 나타내며, 카디널리티가 낮으면 중복도가 높은 것을 의미한다.
  - ‘인덱스 선택도’는 인덱스 컬럼을 모두 ‘=’로 조회할 때 평균적으로 선택되는 비율을 의미한다.
  - 선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효용가치가 별로 없다. 테이블 액세스가 많이 발생하기 때문이다.
  
  - 컬럼 순서 결정 시, 선택도 이슈
    - 결합 인덱스 컬럼 간 순서를 정할 때도 카디널리티는 인덱스 스캔에 큰 영향을 미치지 않는다.
    - 예시
      ```
      WHERE 성별 = :gender
      AND 고객번호 = :custNo
      ```
      - 구체적인 예로 아래 쿼리에서 고객번호를 앞에 두는 것이 유리하다고 생각하겠지만, 그렇지 않다. 성별과 고객번호 중 어떤 컬럼이 앞으로 오든 인덱스 스캔 효율에 전혀 차이가 없다. 
      - 둘 다 인덱스 액세스 조건이므로 어떤 컬럼이 앞으로 오든 인덱스 스캔 범위는 똑같다.
    - 인덱스 설계할 때 우리가 할 일은 ‘항상 사용하는’ 컬럼을 앞쪽에 두고 그 중 ‘=’ 조건을 앞쪽에 위치시키는 것뿐이다. 
    - 그중 선택도가 낮은 컬럼을 앞쪽에 두려는 노력은 의미 없거나 오히려 손해일 수 있다.
  - 인덱스 생성 여부를 결정할 때에는 카디널리티가 중요하지만, 컬럼 순서를 결정할 때에는 카디널리티보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이 된다.
  
- 중복 인덱스 제거
  - 완전 중복
    ```
    X01: 계약ID + 청약일자
    X02: 계약ID + 청약일자 + 보험개시일자
    X03: 계약ID + 청약일자 + 보험개시일자 + 보험종료일자
    ```
    - 인덱스가 같고 선두컬럼까지 일치하기 때문에 완전 중복으로 X01, X02는 삭제해도 된다.
     
  - 불완전 중복
    ```
    X01: 계약ID + 청약일자
    X02: 계약ID + 보험일자
    X03: 계약ID + 보험종료일자
    X04: 계약ID + 데이터생성일자
    ```
    - 두번째 컬럼이 모두 다르지만 계약ID의 카디널리티가 매우 낮다면 사실상 중복이기 때문에 아래와 같이 하나만 만들어도 충분하다
      ```
      X01: 계약ID + 청약일자 + 보험일자 + 보험종료일자 + 데이터생성일자
      ```
      
#### 참고

- 조시형 저자의 개발자를 위한 SQL 튜닝 입문서 친절한 SQL 튜닝
  - https://url.kr/fjm9l2
- http://wiki.gurubee.net/pages/viewpage.action?pageId=26743000
