---
layout: post
title: SQL Tuning. index 기본
summary: SQL Tuning
author: devhtak
date: '2021-11-03 21:41:00 +0900'
category: SQL
---

#### 테이블 액세스 최소화

- 인덱스를 통해 조회하는 것이 table full scan보다 느릴 때가 있다.
  - 테이블 랜덤 액세스
    - 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까
      - 물리적 주소: 데이터파일 번호, 오브젝트 번호, 블록 번호와 같은 물리적 요소로 구성되어 있다.
      - 논리적 주소: 물리적(포인터)으로 직접 연결되어 있지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있다
      - 그래서 논리적 주소에 더 가깝다
    - 메인 메모리 DB와 비교
      - 메인 메모리 DB는 모든 데이터를 메인 메모리에 로드해 놓고 메모리를 통해서만 I/O 하는 DB
      - 오라클은 데이터 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되는 데 이럴 때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조
        - 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(DBA, Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다
    - I/O 메커니즘
      - I/O 성능을 높이기 위해 버퍼 캐시를 활용하기 때문에 버퍼 캐시를 찾은 후 데이터를 찾지 못하는 경우 디스크를 찾는 과정을 거친다 
      - 해싱 알고리즘을 통해 버퍼 헤더를 찾고, 헤더 내에서 얻은 포인터로 버퍼 블록을 찾는다.

  - 인덱스 클러스터링 팩터
    - 클러스터링 팩터(Clustering Factor)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
    - CF가 좋은 컬럼에 생성한 인덱스는 그만큼 스캔하는 부분이 작기 때문에 좋은 효율을 갖게 된다.
      - 테이블 액세스량에 비해 블록 I/O가 적게 발생하는 것

  - 인덱스 손익분기점
    - Index Range Scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 시점을 인덱스 손익분기점이라고 부른다
    - Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
    - Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID는 Single Block I/O 이다

- 인덱스 컬럼 추가
  - 가장 일반적으로 사용하는 튜닝 기법
  - 인덱스를 계속 추가하다 보면 테이블 마다 인덱스가 수십 개씩 달려 인덱스 관리 비용에 증가, DML 부하에 따른 트랜잭션 성능 저하가 발생할 수 있다.
  - 테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 성능 효과를 볼 수 있다.
  
- 인덱스만 읽고 처리
  - Covered 인덱스
    ```
    SELECT 부서번호, SSUM(수량)
    FROM 부서
    WHERE 부서번호 LIKE '12%'
    GROUP BY 부서번호
    ```
    - index가 부서번호인 경우 12로 시작하는  index leaf node를 찾고 해당하는 Table Access한다.
    - 해당에 경우 처럼 Table Access 한만큼 데이터를 가져오는 경우에는 index에 문제가 아닌 일의 양이 많은 것
    - 이럴 때에는 인덱스만 읽어서 처리하도록 사용하는 컬럼을 모두 index로 하는 것을 covered index라고 하며, 이런 경우 성능이 향상된다.
    - 하지만, 사용하는 컬럼이 많으면 실제 적용하기 어렵다
    
  - Include index
    - 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
      ```
      CREATE INDEX emp_x01 ON EMP (DEPTNO) INCLUDE(SAL)
      CREATE INDEX emp_x02 ON EMP (DEPTNO, SAL)
      ```
      - emp_x01은 모든 노드들은 DEPTNO가 있으며 리프 레벨에 노드에는 SAL 컬럼과 함께 저장된다.
      - emp_x02 는 DEPTNO와 SAL 컬럼 모두 루트와 브랜치 블록에 저장한다. 
    - include index는 Table Random Access 횟수를 줄이는 용도로만 사용한다
  
- 인덱스 구조 테이블(Index-Organized Table)
  
  ![image](https://user-images.githubusercontent.com/42403023/141116443-f888d7f6-e5b5-4206-9957-32f44f232dc8.png)

  ```
  CREATE TABLE INDEX_ORT_T(A NUMBER, B VARCHAR(10), CONTRAINT INDEX_ORG_T_PK PRIMARY KEY(A))
  ORGANIZATION INDEX;
  ```
  - Rand Access가 발생하지 않도록 Table을 index 구조로 생성하는 방법
  - index leaf block이 곧 data block이 되며 정렬 상태를 유지하며 데이터를 입력한다.
  - Clustering Factor를 좋게 만드는 방법 중 하나

#### 부분범위 처리 활용

- 부분 범위 처리
  - 전체 쿼리 결과 집합을 쉼없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것 
  - DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다.
    - 전체 결과집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 멈춰 기다린다.
    - 전체 데이터를 보내는 것이 아닌 일정량만 보낸 후 CPU를 OS에 반환하고 대기 큐에서 대기하다 Fetch Call을 받으면 대기 큐에서 나와 그 다음 데이터를 전송한다.
  
  - 정렬 조건이 있을 때 부분범위 처리
    ```
    SELECT NAME 
    FROM BIG_TABLE
    ORDER BY CREATED
    ```
    - CREATED 컬럼으로 정렬하게 되면 부분범위 처리가 가능할까?
      - 모든 데이터를 읽은 후 CREATED 순으로 정렬을 마친 후 클라이언트에게 데이터를 전송하기 때문에 전체범위처리다.
      - 만약 CREATED 컬럼이 선두 index에 경우 부분범위 처리가 가능하다

- 웹 환경에서 부분범위 처리
  - 웹 환경에서는 주로 목록을 조회하는 경우가 발생하기 때문에 이럴 때에는 항상 정렬된 상태를 유지하는 인덱스를 사용하면 정렬 작업을 생략하고 앞쪽 일부 데이터를 빠르게 보여줄 수 있다.
  - 예시
    ```
    SELECT 게시글ID, 제목, 작성자, 등록일시
    FROM 게시판
    WHERE 게시판구분코드='A'
    ORDER BY 등록일시 DESC
    ```
    - 만약 index를 \[게시판구분코드, 등록일시] 로 구성하지 않는다면
      - Order를 생략하지 않는다면 게시판구분코드가 A인 데이터를 등록일시 기준으로 정렬한 후 일정 부분만 가져오기 때문에 의미가 없다.
    - index를 \[게시판구분코드, 등록일시] 로 구성한다면
      - 정렬할 필요가 없기 때문에 게시판구분코드가 A인 데이터 전체를 읽지 않고 정해진 크기만 읽고 처리할 수 있다.

#### 인덱스 스캔 활용화

```
참고) 옵티마이저의 비용 계산 원리
비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
    = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 
      + 인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수
      + 테이블 액세스 과정에 읽는 블록 수
```
- 액세스 조건과 필터 조건
  - 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절로 인덱스 시작점을 찾기 위한 수직적 탐색과 종료지점까지 스캔하는 수평적 스캔을 결정한다.
  - 인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절
  - 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다
  - 비교연산자 종류와 컬럼 순서에 따른 군집성
    - 테이블과 달리 인덱스는 데이터가 정렬되어 있기 때문에 '=' 연산에 경우 모여있는 레코드를 갖게 된다
    ```
    /* 조건절 1 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4='a'
    /* 조건절 2 */
    WHERE C1 = 1 AND C2='A' AND C3='나' AND C4 >= 'a'
    /* 조건절 3 */
    WHERE C1 = 1 AND C2='A' AND C3 between '가' AND '다' AND C4='a'
    /* 조건절 4 */
    WHERE C1 = 1 AND C2 <= 'B' AND C3='나' AND C4 between 'a' and 'b'
    /* 조건절 5 */
    WHERE C1 between 1 and 4 AND C2='A' AND C3='나' AND C4='a'
    ```
    - 조건절 1. 선행조건들이 모두 정렬되어 있다.
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 2. 맨 마지막 조건만 범위검색 조건으로일 때에도 레코드가 서로 모여 있다
      - 인덱스 액세스 조건: C1, C2, C3, C4
      - 인덱스 필터 조건: X
    - 조건절 3. 중간에 데이터가 범위 검색 조건에 경우 C1~C3까지는 모여있지만 C4 조건에 해당하는 데이터는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2, C3
      - 인덱스 필터 조건: C4
    - 조건절 4. C1, C2 조건에 해당하는 레코드는 모여있지만, C3, C4는 흩어져 있게 된다
      - 인덱스 액세스 조건: C1, C2
      - 인덱스 필터 조건: C3, C4
    - 조건절 5.
      - 인덱스 액세스 조건: C1
      - 인덱스 필터 조건: C2, C3, C4
  - 
  

#### 인덱스 설계

#### 참고

- 조시형 저자의 개발자를 위한 SQL 튜닝 입문서 친절한 SQL 튜닝
  - https://url.kr/fjm9l2
