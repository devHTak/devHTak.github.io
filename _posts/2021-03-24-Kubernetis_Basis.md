---
layout: post
title: Kubernetes 들어가기
summary: Kubernetes
author: devhtak
date: '2021-03-24 21:41:00 +0900'
category: Container
---

#### 쿠버네티스 소개

- 쿠버네티스 시작
  - 오랜 세월 동안 구글은 Borg(보그)라는 내부 시스템을 개발
  - 애플리케이션 개발자와 시스템 관리자가 수천 개의 애플리케이션과 서비스를 관리하는 데 도움
  - 조직 규모가 클 때 엄청난 가치를 발휘
  - 수십만 대의 시스템을 가동할 때 사용률이 조금만 향상돼도 수백만 달러의 비용 절감 효과
  - 구글은 보그와 오메가를 15년동안 비밀로 유지하다 2014년 구글 시스템을 통해 얻은 경험을 바탕으로 한 오픈소스 시스템인 '쿠버네티스'를 출시
  - 인프라의 추상화
    - 컨테이너 시스템에서 컨테이너 애플리케이션을 쉽게 배포, 관리하도록 돕는 소프트웨어 시스템
    - 기본 인프라를 추상화해 개발 및 운영팀의 개발, 배포, 관리를 단순화
    - 모든 노드가 하나의 거대한 컴퓨터인 것처럼 수천개의 컴퓨터 노드에서 소프트웨어 애플리케이션을 실행

- 쿠버네티스 장점
  - 애플리케이션 배포 단순화
    - 특정 베어메탈을 필요로 하는 경우 SSD/HHD 등에 라벨링을 하여 배포를 단순화할 수 있다.
    - 가상화 아키텍처에서 크게 두 가지로 분류하는데, 호스트형 가상화와 베어메탈 가상화이다.
    - 호스트형 가상화는 호스트 운영체제가 있고, 그 위에 가상머신을 구현한 방식
    - 베어메탈 가상화는 호스트 운영체제가 없고, 하드웨어 상에 하이퍼바이저가 바로 설치되고, 이 위에 가상 머신을 구현한 방식
  - 하드웨어 활용도 극대화
    - 클러스터의 주변에 자유롭게 이동하여 실행중인 다양한 애플리케이션 구성 요소를 클러스터 노드의 가용 리소스에 최대한 맞춰 서로 섞고 매치
    - 노드의 하드웨어 리소스를 최상으로 활용
  - 상태 확인 및 자가 치유
    - 애플리케이션 구성 요소와 실행되는 노드를 모니터링 하고 노드 장애 발생시 다른 노드로 일정을 자동으로 재조정
    - 자동으로 리소스를 모니터링하고 각 애플리케이션에서 실행되는 인스턴스 수를 계속 조정하도록 지시 가능
  - 오토스케일링
    - 개별 애플리케이션의 부하를 지속적으로 모니터링할 필요 없이 자동으로 리소스를 모니터링하고 각 애플리케이션에서 실행되는 인스턴스 수를 계속 조정하도록 지시 가능
  - 애플리케이션 개발 단순화
    - 버그 발견 및 수정 (완전히 개발환경과 같은 환경 제공)
    - 새로운 버전 출시 시 자동으로 테스트, 이상 발견 시 롤아웃

- 개발자 돕기: 핵심 애플리케이션 기능에 집중
  - 애플리케이션 개발자가 특정 인프라 관련 서비스를 애플리케이션에 구현하지 않아도 된다.
  - 쿠버네티스에 의존하여 서비스 제공
    - 서비스 검색, 확장, 로드밸런싱, 자가 치유, 리더 선출 등
  - 애플리케이션 개발자는 애플리케이션의 실제 기능을 구현하는 데 주력
  - 인프라와 인프라를 통합하는 방법을 파악하는 데 시간을 낭비할 필요가 없다.

- 운영 팀 돕기: 효과적으로 리소스를 활용
  - 실행을 유지하고 서로 통신할 수 있도록 컴포넌트에 정보 제공
  - 애플리케이션이 어떤 노드에서 실행되는지 상관 없다.(신경 쓰지 않아도 된다.)
  - 언제든지 애플리케이션을 재배치 가능
  - 애플리케이션을 혼합하고 매장시킴으로써 리소스를 매칭

#### 쿠버네티스 아키텍처

- 쿠버네티스 클러스터 아키텍처
  - 쿠버네티스의 클러스터는 하드웨어 수준에서 많은 노드로 구성되며 두가지 유형으로 나뉜다.
    - 마스터 노드: 전체 쿠버네티스 시스템을 관리하고 통제하는 쿠버네티스 컨트롤 플레인을 관장한다.
    - 워커 노드: 실제 배포하고자 하는 애플리케이션의 실행을 담당한다.
    - 마스터 노드에 여러 워커 노드를 운영할 수 있다. 마스터 노드 또한 이중화할 수 있다.
    
  ![kubernetes architecture](../images/docker/KubernetesArchitecture.PNG)
  - 이미지 출처: https://medium.com/@chkrishna/kubernetes-architecture-f7ca63fff46e
  
  - Kubernetes Control Plain (Masters)
    - Control plain에서는 클러스터를 관리하고 클러스터의 기능
    - 단일 마스터 노드에서 실행하거나 여러 노드로 분할되고 복제해 고가용성을 보장
    - 클러스터의 상태를 유지하고 제어하지만 애플리케이션을 실행하지 않는다.
    - 구성 요소
      - kube-apiserver(쿠버네티스 API 서버): 사용자, Control Plain과 통신
      - kube-scheduler(스케줄러): 애플리케이션 예약(애플리케이션의 배포 가능한 각 구성 요소에 워커 노드를 할당)
      - Control-manager: 구성 요소 복제, 워커 노드 추적, 노드 장애 처리 등 클러스터 수준 기능을 실행
      - etcd(데이터 스토리지): 클러스터 구성을 지속적으로 저장하는 안정적인 분산
      
  - Worker Node
    - 컨테이너화된 애플리케이션을 실행하는 시스템
    - 애플리케이션에 서비스를 실행, 모니터링, 제공하는 작업은 다음과 같은 구성요소로 수행
      - Container runtime: 컨테이너를 실행하는 도커
      - Kubelet: APi 서버와 통신하고 노드에서 컨테이너를 관리
      - Kubernetes Service, Proxy: 애플리케이션 간에 네트워크 트래픽을 분산 및 연결

- 쿠버네티스에서 애플리케이션 실행
  - 개발자가 미리 만든 이미지를 이미지 레지스트리에 push한다.
  - 쿠버네티스에 올리길 원하면, yaml 또는 json으로 app descriptor를 작성한다.
  - control plain(master)가 descriptor를 참조하여 worker node의 kublet에 이미지를 배치하도록 명령한다.
  - 이 후 이미지 레지스트리에서 이미지를 worker node에 세팅한 후 실행한다.
  - 개발자는 이미지를 만든 후 push하고 control plain에 descrption을 제출한다.










** 출처: 인프런 강의
