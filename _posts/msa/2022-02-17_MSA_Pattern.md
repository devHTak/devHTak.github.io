#### MSA Pattern 과 Architecture

##### Service Discovery Pattern

![image](https://user-images.githubusercontent.com/42403023/154488723-b5f32ac1-4f3f-42ea-9dc0-a69f78b89b70.png)
	
- 클라이언트가 여러 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능과 로드밸런싱 기능이 제공해야 한다
  - Netflix OSS 에서 라우팅 기능은 Zuul, 로드 밸런싱은 Ribbon이 담당한다
- 라우팅을 하기 위해 IP 주소를 알아야 하는 데, 클라우드 환경에서 유동 IP 정보를 매번 전송받아 변경해야 한다
- 유동적인 IP 정보를 매핑하여 보관할 저장소로 Netfilx OSS의 Eureka가 그 기능을 담당한다
- 디스커버리 패턴 절차
  - 서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다.
	- 클라이언트가 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 IP를 확인하 후 호출
	- 서비스가 종료될 때 위치 정보가 삭제된다
	
##### API Gateway Pattern

![image](https://user-images.githubusercontent.com/42403023/154488814-c432d982-0ad1-49d4-9bd0-18c12994c2b6.png)
	
- 여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하게 된다면 매우 복잡한 호출관계가 만들어 지는 데, 이런 복잡함을 해결하기 위한 방법이 API Gateway Pattern이다
- 서비스 라우팅 기능은 L4 와 같은 하드웨어로 구현할 수 있고 소프트웨어로 구현할 수 있는데, 소프트웨어로 구현할 경우 애플리케이션 레벨의 라우팅 기능을 제공한다
  - 로드 밸런싱 역할, 필터를 활용한 선행, 후행 처리, 에러 처리 등을 구현할 수 있다
- API 게이트웨이 제공 기능
  - 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
  - 보안: 권한 서비스와 연계한 인증/인가
  - 로드 집계 서비스와 연계한 로깅 (예, API 소비자 정보, 요청/응답 데이터)
  - 메트릭(Metrics) (예, 에러율, 평균/최고 지연시간, 호출 빈도 등)
  - 트레이싱 서비스와 연계한 서비스 추적 (예, 트래킹 ID 기록)
  - 모니터링 서비스와 연게한 장애 격리(서킷브레이커 패턴)
- 서비스
  - Spring Cloud - Spring API Gateway Service
  - Kubernetes - Service, Ingress Resources

##### BFF(Backend for Frontend) Pattern

![image](https://user-images.githubusercontent.com/42403023/154488938-57fc40ed-19b2-4725-bb4d-1dad6b33d7fc.png)
	
- 다양한 클라이언트를 고려하여 특화된 처리를 위한 API 조합이나 처리가 필요한 데 이 때 BFF 패턴을 사용한다
- BFF 패턴은 API 게이트웨이와 같은 진입점을 하나만 두는 것이 아닌 프론트엔드 유형에 따라 각각 두는 패턴이다
- 각 프런트엔드에 대한 BFF를 두고 통합적인 API를 두어 공통에 인증/인가, 로깅 처리등을 구성할 수 있다

##### 외부구성 저장소 패턴

- 클라우드 인프라와 같이 유연한 인프라를 사용하는 상황에서 데이터이스 연결 정보, 파일 스토리지 정보 같은 내용을 애플리케이션에 포함하는 경우 재배포가 필요하다
- 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리할 필요가 있는 데 이를 위한 패턴이 외부 저장소 패턴이다
  - 외부 저장소는 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 백업 저장소이다
- 서비스
  - Spring Cloud: Spring Cloud Config
  - Kubernetes: ConfigMap

##### 인증 인가 패턴

- 각 서비스별 인증/인가를 중복으로 구현한다면 비효율적이다
- 인증/인가를 위한 패턴
  - 중앙집중식 세션 관리
    - 기존 모놀리식 방식처럼 서비스 별 세션에 저장하는 것이 아닌 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻도록 한다. 세션 저장소로 레디스(Redis), Memcached를 사용
  - 클라이언트 토큰
    - 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장된다
    - 토큰(JWT)은 사용자의 신원 정보를 가지고 있고 서버로 요청을 보낼 때 전송되기 때문에 서버에서 인가 처리를 할 수 있다
    - 메커니즘
      - 브라우저가 서버에 사용자명과 패스워드로 인증을 요청
      - 서버는 인증 후 토큰을 생성하고 브라우저에 토큰에 사용자 정보의 인증/인가 정보를 포함에 전송한다
      - 브라우저는 서버 리소스를 요청할 때 톤을 함께 보낸다. 서버의 서비스는 토큰 정보를 확인한 후 자원 접근을 허가한다.
  - API Gateway를 사용한 클라이언트 토큰
    - API Gateway가 외부 요청의 입구로 추가되어 인증/인가를 처하기 위한 별도의 전담 서비스를 만들어 주는 것(auth service)
      - 동작 메커니즘
      - 클라이언트가 리소스 서비스에 접근을 요청하면 API Gateway는 인증 서비스에게 전달한다
      - 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지(인증), 해당 리소스에 대한 접근 권한이 있는지(인가) 확인하고, 모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토크을 발급한다
      - 클라이언트는 다시 액세스 토큰을 활용해 접근을 요청
      - 그럼 각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지 판단해서 리소스에 대한 접근을 허용한다

##### 서킷 브레이커 패턴

- 장애가 발생한 서비스를 격리하여 유연하게 처리할 수 있는 패턴이 서킷 브레이커 패턴이다
- A라는 서비스가  B라는 서비스를 호출해서 자신의 서비스를 제공하는데, B 서비스에서 장애가 발생하면 A는 계속 기다리게 되며 A 서비스에서도 장애가 발생한 것으로 느끼게 된다
  - B 서비스에서 장애로 인해 호출 실패 횟수가 임곗값을 초과하면 회로 차단기처럼 B 서비스를 호출하는 모든 시도를 즉시 실패하게 만든다
  - Fallback 메서드를 지정하면 장애 발생 시 fallback 메서드가 실행되도록 한다

##### 모니터링과 추적 패턴

- 장애를 실시간으로 감지하고 서비스 간의 호출 어떠한지 확인하기 위해 모니터링, 추적 패턴이필요하다
- Spring Cloud 에서는 Hystrix를 통해 모니터링 할 수 있다
- 분산트레싱 서비스(Zipkin)를 통해 모니터링과 함께 각 서비스 트랜잭션의 호출을 추적하며 마이크로 서비스 운영에 매우 유용하다

##### 중앙화된 로그 집계 패턴

- 마이크로서비스의 로그를 관리하기 위해 중앙화된 로그 집계 패턴이필요하다
- ELK 스택
  - Elasticsearch - 분산형 검색, 분석 엔진: 정형, 비정형, 위치 정보, 메트릭 등 원하는 방법으로 검색을 수행, 결합 가능
  - Logstash - 로그 집합기: 데이터 처리 파이프라인. 다양한 소스에서 동시에 데이터를 수집해 변환한 뒤 특정 보관소로 데이터를 보냄
  - Kibana - 시각화: 히스토그램, 막대 그래프, 파이차트 등 표현. 위치 데이터, 시계열 분석, 그래프 관계 탐색 등 지원
		
##### 서비스 메시 패턴

- MSA 문제 영역 해결을 위한 기능을 비즈니스 로직과 분리하여 네트워크 인프라 계층에서 수해하게 하는 서비스 메시 패턴이 선호되고 있다
- 서비스 메시는 인프라 레이어로 서비스 간의 통신을 처리하며 앞에서 언급한 여러 문제 해결 패턴을 포괄한다
- 구글의 Istio
  - 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴을 적용하여 서비스 디스커버리, 라우팅, 로드밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다
  - Control Plain 기능에 의해 중앙 통제되며 사이드카끼리 통신으로 운영 관리 기능을 제공한다
    - 이를 통해 마이크로서비스의 비즈니스 로직과 독립적으로 운영된다
- Spring Cloud , Netflix OSS와의 차이점
  - 애플리케션 코드의 변경이 거의 없다. Yaml 파일로 정의 된다
  - 폴리글랏 애플리케이션도 지원한다
  - 이스티오는 쿠버네티스와 완벽하게 통합된 환경을 지원한다


##### 출처
	- 이미지 출처: https://microservices.io/patterns/server-side-discovery.html
	- 이미지 출처: https://istio.io/latest/docs/ops/deployment/architecture/arch.svg
