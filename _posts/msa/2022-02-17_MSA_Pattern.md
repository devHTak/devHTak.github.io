---
layout: post
title: MSA Pattern
summary: Spring Cloud
author: devhtak
date: '2022-02-17 14:41:00 +0900'
category: msa
---

##### Service Discovery Pattern

![image](https://user-images.githubusercontent.com/42403023/154488723-b5f32ac1-4f3f-42ea-9dc0-a69f78b89b70.png)
	
- 클라이언트가 여러 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능과 로드밸런싱 기능이 제공해야 한다
  - Netflix OSS 에서 라우팅 기능은 Zuul, 로드 밸런싱은 Ribbon이 담당한다
- 라우팅을 하기 위해 IP 주소를 알아야 하는 데, 클라우드 환경에서 유동 IP 정보를 매번 전송받아 변경해야 한다
- 유동적인 IP 정보를 매핑하여 보관할 저장소로 Netfilx OSS의 Eureka가 그 기능을 담당한다
- 디스커버리 패턴 절차
  - 서비스 인스턴스가 로딩될 때 자신의 서비스 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다.
	- 클라이언트가 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 IP를 확인하 후 호출
	- 서비스가 종료될 때 위치 정보가 삭제된다
	
##### API Gateway Pattern

![image](https://user-images.githubusercontent.com/42403023/154488814-c432d982-0ad1-49d4-9bd0-18c12994c2b6.png)
	
- 여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하게 된다면 매우 복잡한 호출관계가 만들어 지는 데, 이런 복잡함을 해결하기 위한 방법이 API Gateway Pattern이다
- 서비스 라우팅 기능은 L4 와 같은 하드웨어로 구현할 수 있고 소프트웨어로 구현할 수 있는데, 소프트웨어로 구현할 경우 애플리케이션 레벨의 라우팅 기능을 제공한다
  - 로드 밸런싱 역할, 필터를 활용한 선행, 후행 처리, 에러 처리 등을 구현할 수 있다
- API 게이트웨이 제공 기능
  - 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
  - 보안: 권한 서비스와 연계한 인증/인가
  - 로드 집계 서비스와 연계한 로깅 (예, API 소비자 정보, 요청/응답 데이터)
  - 메트릭(Metrics) (예, 에러율, 평균/최고 지연시간, 호출 빈도 등)
  - 트레이싱 서비스와 연계한 서비스 추적 (예, 트래킹 ID 기록)
  - 모니터링 서비스와 연게한 장애 격리(서킷브레이커 패턴)
- 서비스
  - Spring Cloud - Spring API Gateway Service
  - Kubernetes - Service, Ingress Resources
  
- vs Gateway routing pattern 
##### BFF(Backend for Frontend) Pattern

![image](https://user-images.githubusercontent.com/42403023/154488938-57fc40ed-19b2-4725-bb4d-1dad6b33d7fc.png)
	
- 다양한 클라이언트를 고려하여 특화된 처리를 위한 API 조합이나 처리가 필요한 데 이 때 BFF 패턴을 사용한다
- BFF 패턴은 API 게이트웨이와 같은 진입점을 하나만 두는 것이 아닌 프론트엔드 유형에 따라 각각 두는 패턴이다
- 각 프런트엔드에 대한 BFF를 두고 통합적인 API를 두어 공통에 인증/인가, 로깅 처리등을 구성할 수 있다

##### 외부구성 저장소 패턴

- 클라우드 인프라와 같이 유연한 인프라를 사용하는 상황에서 데이터이스 연결 정보, 파일 스토리지 정보 같은 내용을 애플리케이션에 포함하는 경우 재배포가 필요하다
- 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리할 필요가 있는 데 이를 위한 패턴이 외부 저장소 패턴이다
  - 외부 저장소는 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 백업 저장소이다
- 서비스
  - Spring Cloud: Spring Cloud Config
  - Kubernetes: ConfigMap

##### 인증 인가 패턴

- 각 서비스별 인증/인가를 중복으로 구현한다면 비효율적이다
- 인증/인가를 위한 패턴
  - 중앙집중식 세션 관리
    - 기존 모놀리식 방식처럼 서비스 별 세션에 저장하는 것이 아닌 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻도록 한다. 세션 저장소로 레디스(Redis), Memcached를 사용
  - 클라이언트 토큰
    - 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장된다
    - 토큰(JWT)은 사용자의 신원 정보를 가지고 있고 서버로 요청을 보낼 때 전송되기 때문에 서버에서 인가 처리를 할 수 있다
    - 메커니즘
      - 브라우저가 서버에 사용자명과 패스워드로 인증을 요청
      - 서버는 인증 후 토큰을 생성하고 브라우저에 토큰에 사용자 정보의 인증/인가 정보를 포함에 전송한다
      - 브라우저는 서버 리소스를 요청할 때 톤을 함께 보낸다. 서버의 서비스는 토큰 정보를 확인한 후 자원 접근을 허가한다.
  - API Gateway를 사용한 클라이언트 토큰
    - API Gateway가 외부 요청의 입구로 추가되어 인증/인가를 처하기 위한 별도의 전담 서비스를 만들어 주는 것(auth service)
      - 동작 메커니즘
      - 클라이언트가 리소스 서비스에 접근을 요청하면 API Gateway는 인증 서비스에게 전달한다
      - 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지(인증), 해당 리소스에 대한 접근 권한이 있는지(인가) 확인하고, 모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토크을 발급한다
      - 클라이언트는 다시 액세스 토큰을 활용해 접근을 요청
      - 그럼 각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지 판단해서 리소스에 대한 접근을 허용한다

##### 서킷 브레이커 패턴

- 장애가 발생한 서비스를 격리하여 유연하게 처리할 수 있는 패턴이 서킷 브레이커 패턴이다
- A라는 서비스가  B라는 서비스를 호출해서 자신의 서비스를 제공하는데, B 서비스에서 장애가 발생하면 A는 계속 기다리게 되며 A 서비스에서도 장애가 발생한 것으로 느끼게 된다
  - B 서비스에서 장애로 인해 호출 실패 횟수가 임곗값을 초과하면 회로 차단기처럼 B 서비스를 호출하는 모든 시도를 즉시 실패하게 만든다
  - Fallback 메서드를 지정하면 장애 발생 시 fallback 메서드가 실행되도록 한다

##### 모니터링과 추적 패턴

- 장애를 실시간으로 감지하고 서비스 간의 호출 어떠한지 확인하기 위해 모니터링, 추적 패턴이필요하다
- Spring Cloud 에서는 Hystrix를 통해 모니터링 할 수 있다
- 분산트레싱 서비스(Zipkin)를 통해 모니터링과 함께 각 서비스 트랜잭션의 호출을 추적하며 마이크로 서비스 운영에 매우 유용하다

##### 중앙화된 로그 집계 패턴

- 마이크로서비스의 로그를 관리하기 위해 중앙화된 로그 집계 패턴이필요하다
- ELK 스택
  - Elasticsearch - 분산형 검색, 분석 엔진: 정형, 비정형, 위치 정보, 메트릭 등 원하는 방법으로 검색을 수행, 결합 가능
  - Logstash - 로그 집합기: 데이터 처리 파이프라인. 다양한 소스에서 동시에 데이터를 수집해 변환한 뒤 특정 보관소로 데이터를 보냄
  - Kibana - 시각화: 히스토그램, 막대 그래프, 파이차트 등 표현. 위치 데이터, 시계열 분석, 그래프 관계 탐색 등 지원
		
##### 서비스 메시 패턴

- MSA 문제 영역 해결을 위한 기능을 비즈니스 로직과 분리하여 네트워크 인프라 계층에서 수해하게 하는 서비스 메시 패턴이 선호되고 있다
- 서비스 메시는 인프라 레이어로 서비스 간의 통신을 처리하며 앞에서 언급한 여러 문제 해결 패턴을 포괄한다
- 구글의 Istio
  - 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴을 적용하여 서비스 디스커버리, 라우팅, 로드밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다
  - Control Plain 기능에 의해 중앙 통제되며 사이드카끼리 통신으로 운영 관리 기능을 제공한다
    - 이를 통해 마이크로서비스의 비즈니스 로직과 독립적으로 운영된다
- Spring Cloud , Netflix OSS와의 차이점
  - 애플리케션 코드의 변경이 거의 없다. Yaml 파일로 정의 된다
  - 폴리글랏 애플리케이션도 지원한다
  - 이스티오는 쿠버네티스와 완벽하게 통합된 환경을 지원한다

##### 마이크로 통신 패턴

- 동기 통신 방식
  - 서버측에 존재하는 REST API를 호출할 때 사용하는 방식
  - 라우팅 및 로드밸런싱을 원활하게 하기 위해서 중간에 Api Gateway를 둘 수 있다.
  - 동기 방식은 요청을 보낸 서비스에 응답이 올때까지 기다리며 반응이 오지 않으면 계속 기다리면서 재호출한다
    - 이와 같은 상황에서 장애가 연쇄적으로 발생할 수 있다.
    - 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는 의존관계가 높다는 것을 의미한다
- 비동기 통신 방식
  - 메시지를 보낸 다음 응답을 기다리지 않고 다음 일을 처리한다
  - 결과에 대한 응답을 받기는 어렵기 때문에 이를 보장하기 위해 Message Broker(Apache Kafka, Rabbit MQ, Active MQ)를 사용한다
    - Producer, Consumer가 직접 연결하는 것이 아닌 메시지 브로커에 연결된다
  - 각 서비스 간에 의존관계가 높지 않기 때문에 서비스 확장 등에 용이하다
  - 비동기 방식의 이벤트 기반 아키텍처
    - 분산시스템간에 발신자가 이벤트를 생성 및 발행하고 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 구독하고 처리하는 형태의 시스템 아키텍처
    - 이벤트 기반 아키텍처는 이벤트를 생산하는 모듈과 이벤트에 대응하는 모듈을 분리하고 상호 독립적으로 동작하게 함으로써 병렬 처리를 촉진한다

##### 저장소 분리 패턴

- 장점
  - 저장소 분리 패턴은 각 마이크로 서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유하는 것
  - 직접 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근(정보 은닉)
  - 격리되어 있기 때문에 저장소를 자율적으로 선택할 수 있다(폴리글랏)
  - 데이터를 통한 변경의 파급 효과(영향도)를 줄여 서비스를 독립적으로 만든다.
- 단점
  - 조인이 불가능 하여 Application side join을 진행해야 한다
  - 또한 비즈니스 정합성, 데이터 일관성 등을 보장하기 위한 것이 문제다

##### 분산 트랜잭션 처리 패턴

- 가장 쉬운 방법은 분산된 서비스를 하나의 일관된 트랜잭션으로 묶는 것
- 2단계 커밋
  - 분산 트랜잭션에 포함되어 있는 모든 노드가 커밋되거나 롤백하는 메커니즘
  - 각 서비스에 잠금(lock in) 상태로 성능 문제 탓에 효율적인 방법은 아니다
  - No SQL은 2단계 커밋을 지원하지 않는다
- SAGA 패턴
  ![image](https://user-images.githubusercontent.com/42403023/154493221-2b7c4e30-29fc-4c06-89e1-26f21024d11b.png)
  
  - 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴
  - 여러개의 분산 트랜잭션을 하나로 묶지 않고, 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스, 데이터 정합성을 맞춘다
  - 롤백이 필요한 경우 보상 트랜잭션을 통해 실패에 경우를 되돌리게 하는 트랜잭션

- 결과적 일관성(eventual consistency)
  - 어떤 비즈니스는 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시간이 됐을 때 일관성을 만족해도 되는 것
  - 이벤트 기반 아키텍처와 메시지 브로커, 사가 패턴으로 비즈니스 정합성을 결과적으로 보장하고 비즈니스 및 시스템 가용성을 극대화할 수 있다.

##### CQRS 패턴 (읽기와 쓰기 분리)

![image](https://user-images.githubusercontent.com/42403023/154495236-c82e874b-394a-455d-8726-eac69ea3bac5.png)

- Command Query Responsibility Segregation: 명령 조회 책임 분리를 의미
- 일반적인 비즈니스 모델에서는 입력, 수정, 삭제가 조회보다 적게 쓰이고 조회 요청이 훨씬 많이 사용된다
- 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 쓰기 서비스와 조회 서비스 분리
- 물리적으로 쓰기 트랜잭션 용 저장소와 조회용 저장소를 따로 준비
  - 쓰기 전략과 조회 전략을 분리함으로써 쓰기 시스템에 부하를 줄이고 조회 대기 시간을 줄이는 이점을 볼 수 있다.
- 데이터 일관성이 깨진다
  - 데이터 일관성을 유지하기 위해 쓰기 이벤트가 발생하면 메시지 브로커에 전달하여 조회 서비스가 읽어와 최신화 할 수 있도록 구성해야 한다
- 시간적 간격이 있을 수 있지만 어느 시점에서 결과적으로 일치하게 된다

##### API 조합과 CQRS 패턴

- 서비스별 저장소가 격리된 상태에서 연계를 위한 방식으로 API 조합과 CQRS 패턴이 있다
- API 조합
  - 서비스간에 독립적인 API를 제공
  - 이 방법은 서비스간에 의존하는 결과를 가져오게 된다
  - 의존성을 줄이기 위한 방법으로 CQRS 패턴 사용이 가능하다
- CQRS 패턴
  - 쓰기가 발생하는 서비스에서 변경 이벤트를 전달하면 조회용 서비스에서 해당 이벤트를 가져와 일관성을 맞추어 서비스할 수 있다
  - 다른 서비스에 장애가 발생하여도 조회용 서비스에 영향을 받지 않는다

##### 이벤트 소싱 패턴(쓰기 최적화)

- 객체에 변화 이벤트를 받아 다시 SQL로 변환하는 작업은 번거롭다
- 이벤트 소싱 패턴을 사용하여 객체 상태를 데이터 모델에 맞추는 것이 아닌 트랜잭션 자체를 저장하는 전략이다
  - 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있다
  - CRUD를 모두 사용하는 것이 아닌 C(입력), R(조회)만 처리
  - 이벤트 타입의 상태, 객체, 변경 내용을 JSON 형태로 저장
- 모든 트랜잭션을 처리하는 것이 부담스러운 경우 스냅샷을 활용하여 이후의 트랜잭션만 처리할 수 있다
- 모든 트랜잭션의 상태를 계산하지 않고 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장하는 방식
  - 이벤트 스트림 저장소는 추가만 가능하여 이벤트를 쌓고, 구체화하는 시점에서 트랜잭션을 바탕으로 상태를 계산하여 구성
  - 이벤트 저장소는 이벤트 데이터베이스 뿐만 아니라 메시지 브로커처럼 작동한다

##### 출처
- 이미지 출처: https://microservices.io/patterns/server-side-discovery.html
- 이미지 출처: https://istio.io/latest/docs/ops/deployment/architecture/arch.svg
- 이미지 출처: https://medium.com/design-microservices-architecture-with-patterns/cqrs-design-pattern-in-microservices-architectures-5d41e359768c
- 내용 출처: 도메인 주도 설계로 시작하는 마이크로서비스 개발(http://www.yes24.com/Product/Goods/98880996)
