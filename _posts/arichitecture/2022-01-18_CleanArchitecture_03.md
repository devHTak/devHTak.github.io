---
layout: post
title: Clean Architecture 03. 설계원칙
summary: Clean Architecture 
author: devhtak
date: '2022-01-15 21:41:00 +0900'
category: Architecture
---

#### 12장 컴포넌트

- 컴포넌트의 이해
  - 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위이다
    - 자바 -> jar
  - 컴포넌트가 마지막으로 어떤 형태로 배포되든 잘 설계된 컴포넌트라면 반드시 독립적으로 배포가 가능해야 하며 독립적으로 개발 가능한 능력을 갖춰야 한다.

- 컴포넌트의 간략한 역사
  - 소프트웨어 개발 초창기에는 프로그램이 로드될 주소를 직접 제어해야 했다.
    - 라이브러리 함수에 접근하려면 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함 시켜서 단일 프로그램으로 컴파일 했다.
  - 컴파일 과정은 오래 걸렸고 메모리는 비싸 한정적이였다.
    - 컴파일 시간을 단축시키기 위해 함수 라이브러리를 개별적으로 컴파일 했다.
    - 라이브러리를 로드한 다음 메모리 주소에 접근하는 방식으로 라이브러리를 사용했다.
  - 점점 프로그램과 라이브러리의 크기가 커지면서 사용하는 메모리가 늘어나 단편화가 심해졌다. 따라서 이러한 방식은 지속 가능하지 않았다.

- 재배치성
  - 해결책은 재배치가 가능한 바이너리(relocatable binary)였다. 
    - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방법이다.
  - 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(external reference)로 생성했다.
    - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의(external definition)로 생성했다.
    - 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있다.
  - 링킹 로더(linking loader)가 탄생했다.

- 링커
  - 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
  - 이 후, 링킹 로더의 속도가 너무 느려져서 로드와 링크를 분리한다.
    - 프로그래머가 느린 부분인 링크 과정을 맡아 링커라는 별도의 애플리케이션으로 이 작업을 처리한다.
    - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 결과 로더의 로딩 과정이 아주 빨라졌다.
  - C나, 고수준 언어를 사용하면서 코드가 수십만 라인을 넘어서며 결국 컴파일과 링커에서 걸리는 시간이 다시 늘어났다.
  - 무어(Moore)가 등장해 이를 해결하자 디스크는 작아지기 시작했고, 놀랄 만큼 빨라졌다.
    - 컴퓨터 메모리는 말도 안 될 정도로 저렴해졌다.
    - 이렇게 액티브 X와 공유 라이브러리 시대가 열렸다.
  - 컴퓨터와 장치가 빨라져서 또다시 로드와 링크를 동시에 할 수 있게 되었다.
    - 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한후, 링크가 끝난 프로그램을 실행할 수 있게 되었다.
    - 이렇게 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했다.

#### 13장 컴포넌트 응집도

- 컴포넌트 응집도 3가지 원칙
  - REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
  - CCP : 공통 폐쇄 원칙 (Common Closure Principle)
  - CRP : 공통 재사용 원칙 (Common Reuse Principle)

- REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
  - 재사용 단위는 릴리스 단위와 같다.
    - 재사용을 위해 소프트웨어 컴포넌트는 릴리스 절차를 통해 추적 관리를 위해 릴리스 번호를 부여하며, 서로 호환되는지 보증한다.
    - 또한 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트웨어 개발자들이 알아야 하기 때문입니다.
  - 새로운 릴리스가 나온다면 해당 소스를 사용하는 개발자를 위해 문서 작성도 포함해야 한다.
    - 개발자들이 충분한 정보를 바탕으로 새 릴리스를 통합할지, 한다면 언제 할지 결정할 수 있게된다.
  - 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 함을 뜻한다
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다. 
    - 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다

- CCP : 공통 폐쇄 원칙 (Common Closure Principle)
  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어야 하고, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해야 한다는 원칙
  - 단일 책임 원칙(SRP)을 컴포넌트의 관점에서 정의한 것
    - SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 되는 것처럼 CCP에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다.
  - 대다수의 애플리케이션에서 유지보수성(maintainability)은 재사용성보다 중요하다
    - 애플리케이션의 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 좋다.
    - 만약 변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 됩니다. 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없다.
  - 개방 폐쇄 원칙(OCP)과도 밀접하게 연관되어 있다.
    - CCP에서 말하는 '폐쇄(Closure)'는 OCP에서 말하는 '폐쇄(Closure)'와 같은 의미로 OCP에서는 클래스가 변경에는 닫혀 있고, 확장에는 열려 있어야 한다.
    - 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 합니다.
    - 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아지게 됩니다.

- CRP : 공통 재사용 원칙 (Common Reuse Principle)
  - 컴포넌트 사용자들을 필요한 것만 의존하도록 하는 원칙
  - CRP 또한 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움이 되는 원칙
    - 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다
  - CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지, 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
    - 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생긴다.
    - 사용하는(using) 컴포넌트가 사용되는(used) 컴포넌트에서 단 하나의 클래스만 사용할 수도 있다.
    - 그렇다고 해서 의존성은 조금도 약해지지 않고 여전히 사용하는 컴포넌트가 사용되는 컴포넌트에 의존하고 있다.
  - 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 놓거나 사용하는 컴포넌트를 변경하지 않더라도, 재컴파일, 재검증, 재배포를 해야 하는 가능성이 존재한다.
    - 컴포넌트에서 발생한 변경이 사용하는 컴포넌트와는 전혀 관련이 없는 경우도 마찬가지이다
  - 따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실하게 인지해야 한다.
  - CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기하고 있다. 
    - 즉, CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다는 것을 강조하고 있는 것
  - 위의 맥락은 인터페이스 분리 원칙(ISP)과 문맥이 같다.
    - ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 이야기하고 있고, CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 이야기하고 있다.

- 컴포넌트 응집도에 대한 균형 다이어그램
  ```
  REP <-> CCP: 불필요한 릴리스가 빈번하게 발생한다
  REP <-> CRP: 컴포넌트 변경이 빈번하게 발생한다
  CCP <-> CRP: 재사용이 어렵다
  - REP: 재사용성을 위한 그룹
  - CCP: 유지보수성을 위한 그룹
  - CRP: 불필요한 릴리스를 피하기 위한 분리
  ```
  - REP와 CCP는 포함(inclusive) 원칙으로, 두 원칙은 관련있는 클래스들을 한 컴포넌트로 묶음으로써 컴포넌트를 더욱 크게 만든다. 
  - CRP는 배제(exclusive) 원칙으로, 불필요한 클래스에 의존하지 않도록 분리하여 컴포넌트의 크기를 더욱 작게 만든다.
  - 우리는 이 세 원칙들 사이에서 현재 관심을 기울이는 부분을 충족시키는 균형점를 찾아야 하며, 또한 시간이 흐르면서 이 균형점은 유동적으로 변한다는 것을 인지하자
  
#### 14장 컴포넌트 결합

- 아래 원칙은 컴포넌트 사이의 관계를 설명한다
  - ADP (의존성 비순환 원칙)
  - SDP (안정된 의존성 원칙)
  - SAP (안정된 추상화 원칙)

- ADP (의존성 비순환 원칙)
  ```
  컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
  ```
  
  - 순환 의존성 제거하기
    - 테스트를 완료한 다음에 갑자기 오류가 발생한 다면, 누군가가 의존하고 있는 무언가를 수정하였기 떄문이다.
    - 이에 대한 해결책은 개발 환경을 릴리즈가 가능한 컴포넌트 단위로 분리하는 것이다. 
      - 개발자가 해당 컴포넌트가 동작하도록 만든 후 해당 컴포넌트를 릴리즈하여 다른 개발자가 사용할 수 있도록 만든다.
      - 다른 팀에서는 새 릴리즈를 당장 적용 할지를 결정만 하면 된다.
      - 따라서 특정 컴포넌트가 변경 되더라도 다른 팀에 즉각 영향을 주지는 않는다.
    
    ![image](https://user-images.githubusercontent.com/42403023/149945459-ed128e47-ac8d-4281-bc6d-6842685cfaf1.png)
    
    - 비순환방향 그래프(전형적인)
    - Presenters를 담당하는 팀이 해당 컴포넌트의 새로운 릴리즈를 만든다고 하면 이를 의존하는 컴포넌트는 View, Main이 해당된다. 새로운 릴리즈가 나왔다면 언제 통합 할 지만 결정하면 된다.
    - Main은 새로 릴리즈 되더라도 이로 인해 영향을 받는 컴포넌트는 없다. 또, 시스템 전체를 릴리즈해야 할 때가 오면 릴리즈 절차는 상향식으로 진행된다.

  - 순환이 컴포넌트 의존성 그래프에 미치는 영향
    
    ![image](https://user-images.githubusercontent.com/42403023/149945580-a23bb7ea-34e2-4bd6-a9d6-892719f726f1.png)
    
    - 순환 방향 그래프
    - Database 컴포넌트를 새로 릴리즈한다 하면 DB 컴포넌트가 의존하는 Entities컴포넌트와는 호환이 되어야 하지만 Entities역시 Authorizer 컴포넌트를 의존하고 있어서 DB는 Autorizer와도 호환이 되어야 한다. 
      - 그러나 Authorizer는 Interactors 또한 의존하고 있어 DB는 릴리즈하기 훨씬 어려워진다. 
      - Entities, Authorizer, Interactors는 하나의 거대한 컴포넌트가 되어버린다.
      - 개발자는 3개중 어느것을 개발하더라도 '숙취 증후군'을 경험하게 된다.
    - 단위 테스트 또한 의존하고있는 컴포넌트를 빌드하고 통합 해야해서 릴리즈하는 일도 굉장히 어려워지며 에러도 쉽게 발생하고 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가하게 된다.
    - 이전 내용에서는 전체 시스템을 릴리즈할 때 상향식으로 진행하면 됐지만 순환 구조는 어떤 순서로 빌드하면 되는지 파악하기 상당히 힘들어지기도 한다.
  
  - 순환끊기
    - 컴포넌트 사이의 순환을 끊는 메커니즘 두가지
      - 1) 존성 역전 원칙(DIP)을 적용한다.
      - 2) Entities와 Autorizer가 모두가 의존하는 컴포넌트를 만들며 이 컴포넌트안에 두 컴포넌트가 모두 의존하는 클래스들을 포함시킨다.

  - 흐트러짐
    - 요구사항이 변경되면 컴포넌트 구조도 흐트러지며 변경되기 때문에 순환구조가 발생하는지 항상 관찰해야 한다.

  - 하향식 설계
    - 컴포넌트구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진행한다.

- SDP (안정된 의존성 원칙)
  ```
  안정성의 방향으로(더 안정된 쪽에) 의존하라.
  ```
  - CCP(공통 폐쇄 원칙)을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향을 받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.
    - 변경이 쉽지 않은 컴포넌트가 변동성이 큰 컴포넌트를 의존하게 만들어서는 절대로 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경하기 어려워지기 때문이다.
    - SDP(안정된 의존성 원칙)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

  - 안전성
    - 안정적이란 말은 '쉽게 움직이지 않는'이라고 정의할 수 있다.
    - 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적으로 볼 수 있다. 
      - 많은 컴포넌트들이 의존하고있는 컴포넌트는 사소한 변경이 생기더라도 의존하는 모든 컴포넌트를 만족 시키면서 변경 하려면 상당한 노력이 들기 때문이다.
      ```
      A -> X
      B -> X
      C -> X
      ```
      - X는 세 컴포넌트를 책임진다라고 말할 수 있고 X는어디에도 의존하지 않으므로 독립적이다라고 말할 수 있다.
      ```
      Y -> A
      Y -> B
      Y -> C
      ```
      - Y는 상당히 불안정한 컴포넌트이다. 또한 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다. 이 경우 Y는 의존적이라고 말한다.

  - 안전성 지표
    ```
    Fan-in: 안으로 들어오는 의존성
    Fan-out: 바깥으로 나가는 의존성.
    I(불안정성): I = Fan-out / (Fan-in + Fan-out)
    0 ≤ I ≤ 1
    ```
    - I=0이면 최고로 안정된 컴포넌트이며 반대로 I=1이면 최고로 불안정한 컴포넌트라는 뜻이다.
    - 모든 컴포넌트가 안정적이어야 하는 것은 아니다.
      
      ![image](https://user-images.githubusercontent.com/42403023/149947401-ed831f58-ca02-4b37-9f67-2ea4aab57408.png)
      
      -  SDP가 위배되는 사례이다.
        -  Flexible은 변경하기 쉽도록 설계한 컴포넌트다. 
        -  하지만 Stable 컴포넌트에서 작업하던 개발자가 Flexible에 의존성을 걸게 되었다. 
        -  이로 인해 SDP를 위배하는데, Stable이 Flexible을 의존하기 이전에 Stable의 I지표는 Flexible의 I지표보다는 더 작기 때문이다. 
        -  결국 Flexible은 변경하기가 어렵게 되었다.
      - DIP 로 해결
        - US라는 인터페이스를 생성한 후 UServer 컴포넌트에 넣는다.
        - C가 해당 인터페이스를 구현하도록 만든다. 
          - 이를 통해 Stable의 Flexible에 대한 의존성을 끊을 수 있고, 두 컴포넌트는 모두 UServer에 의존하도록 강제한다. 
          - UServer는 매우 안정된 상태이며(I=0), Flexible은 자신에게 맞는 불안정성(I=1)을 그대로 유지할 수 있다. 이제 모든 의존성은 I가 감소하는 방향으로 향하게 된다.

- SAP (안정된 추상화 원칙)
  - 고수준 정책을 어디에 위치시켜야 하는가?
    - 시스템에서는 자주 변경해서는 절대 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책 결정과 관련된 소프트웨어가 그 예다.
    - 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스코드는 수정 하기가 어려워진다.
    - 컴포넌트가 최고로 안정된 상태이면서도(I=0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있는 방법은 OCP(개방폐쇄원칙)에서 찾을 수 있다.

  - 안정된 추상화 원칙
    - 안정된 추상화 원칙은 안정성과 추상화 정도사이의 관계를 정의한다.
      - 변동성이 적은 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야한다. 
      - 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.
      - SDP(안정된 의존성 원칙)와 SAP(안정된 추상화 원칙)를 결합하면 컴포넌트에 대한 DIP(의존성 역전 원칙)나 마찬가지가 된다. SDP에서는 의존성이 반드시 안정성 방향으로 향하게 되고 SAP는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.
    - 의존성은 추상화 방향으로 향하게 된다.
      - DIP는 클래스에 대한 원칙이며, 클래스는 추상적이거나 아니거나 둘중 하나이다.
      - 반면 SDP와 SAP의 조합은 컴포넌트에 대한 원칙으로 컴포넌트는 어떤 부분은 추상적이며 다른부분은 안정적일 수 있다.

  - 추상화 정도 측정하기
    ```
    Nc: 컴포넌트의 클래스 개수
    Na: 컴포넌트의 추상 클래스와 인터페이스 개수
    A: 추상화 정도, A = Na / Nc
    0 ≤ A ≤ 1
    ```
    - A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다는 뜻이며 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다는 뜻이다.

  - 주계열
    
    ![image](https://user-images.githubusercontent.com/42403023/149948166-16505c3c-648b-4569-b16a-b6129f1eab34.png)
    
    - A(추상화 정도) / I(안정성) 그래프
      - 최고로 안정적이며 추상화된 컴포넌트는 좌측상단 (0,1)에 해당
      - 최고로 불안정적이며 구체화된 컴포넌트는 우측하단 (1,0)에 해당
    - 모든 컴포넌트가 이 두 지점에 위치하지는 않는다.
      - 추상클래스는 흔히 또 다른 추상클래스를 파생한다. 이 파생된 클래스는 추상적이면서도 최고로 안정적인것은 아니다. 의존성으로 인해 안정성이 감소했기 때문이다.
      - 그러므로 모든 컴포넌트가 두 지점에 위치한다는 규칙을 강요할 수 없으므로 A/I 그래프상 합리적인 지점을 정의하는 점의 궤적이 존재한다.

  - 고통의 구역
    
    ![image](https://user-images.githubusercontent.com/42403023/149948353-72659aa2-4761-4544-852c-0cf30f8a3184.png)
    
    - (0,0) 주변 구역에 위치한 컴포넌트는 매우 안정적이며 구체적이다. 
      - 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵다. (0,0) 주변 영역은 배제해야 할 구역이며, 고통의 구역이라고 부른다.
    - (0,0) 근처에 위치한 또 다른 소프트웨어로는 구체적인 유틸리티 라이브러리중 String컴포넌트를 예로 들 수 있다.
      - 이 컴포넌트는 광범위하게 사용되므로 수정해버리면 혼란을 초래한다. 따라서 변동성이 거의 없다.
    - 변동성이 없는 컴포넌트는 (0,0) 구역에 위치했더라도 해롭지 않다. 변동될 가능성이 없기 때문에 변동성이 있는 컴포넌트만 고통의 구역에서 문제가 된다고 정의할 수 있다.

  - 쓸모없는 구역
    - (1,1) 주변의 컴포넌트는 최고로 추상적이지만, 누구도 이 컴포넌트에 의존하지 않기 때문에 쓸모없는 구역이라고 불린다.

  - 배제 구역 벗어나기
    - 두 배제 구역으로부터 가능한 멀리 떨어진 궤적은 (1,0)과 (0,1)을 잇는 선분인 주계열이다.
    - 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 '너무 추상적'이지도 않고, 추상화 정도에 비해 '너무 불안정'하지도 않다.
    - 컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점이지만 저자는 경험을 통해 대규모 시스템에서 소수의 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없다고 말한다.

  - 주계열과의 거리
    
    ![image](https://user-images.githubusercontent.com/42403023/149948536-884672a6-d7df-4dda-92e8-da6b13ed6883.png)
    
    ```
    컴포넌트 산점도
    D : 주계열로부터의 거리
    D = | A + I - 1 |
    0 ≤ D ≤ 1
    ```
    - D가 0이면 컴포넌트가 주계열 바로위에 위치하며, 1이면 주계열로부터 가장 멀리 위치함을 뜻한다.
    
#### Robert C. Martin의 Clean Archiecture 책
