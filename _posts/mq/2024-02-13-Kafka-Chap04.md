---
layout: post
title: Kafka - MessageListener와 @KafkaListener Annotation
summary: Kafka
author: devhtak
date: '2024-02-13 14:41:00 +0900'
category: mq
---

#### MessageListener

- Message Listener Container를 사용할 때 데이터를 수신하기 위해 리스너를 사용해야 하는데, 8개의 Message Listener interface를 제공하고 있다.
  |Listener|Commit|ConsumerRecord|Consumer Access|ETC|
  |---|---|---|---|
  |MessageListener|자동 커밋 또는 container managed commit|개별|X|-|
  |AcknowledgingMessageLsitener|container managed commit|개별|X|-|
  |ConsumerAwareMessageListener|자동 커밋 또는 container managed commit|개별|O|-|
  |AcknowledgingConsumerAwareMessageListener|container managed commit|개별|O|-|
  |BatchMessageListener|자동 커밋 또는 container managed commit|배치|X|AckMode.RECORD 지원하지 않음|
  |BatchAcknowledgingMessageListener|container managed commit|배치|X|-|
  |BatchConsumerAwareMessageListener|자동 커밋 또는 container managed commit|배치|O|AckMode.RECORD 지원하지 않음|
  |BatchAcknowledgingConsumerAwareMessageListener|container managed commit|배치|O|-|

- MessageListenerContainer
  - MessageListenerContainer 구현체 두가지를 제공하고 있다.
    - KafkaMessageListenerContainer: 단일 스레드 환경에서 모든 토픽과 파티션으로부터 메세지를 수신
      ```java
      // KafkaMessageListenerContainer 사용
      @Bean
      public KafkaMessageListenerContainer<String, String> kafkaMessageListenerContainer() {
          // properties
          ContainerProperties properties = new ContainerProperties("SAMPLE");
          properties.setGroupId("SAMPLE1");
          properties.setMessageListener(new MessageListener<>() {
              @Override
              public void onMessage(ConsumerRecord<Object, Object> data) {
                  System.out.println("Consume record: " + data.key() + " " + data.value() + " " + data.offset());
              }
          });
          // consumerFactory
          ConsumerFactory<String, String> consumerFactory = new DefaultKafkaConsumerFactory<>(getConfig());
  
          return new KafkaMessageListenerContainer<String, String>(consumerFactory, properties);
      }      
      ```
    - ConcurrentMessageListenerContainer: 멀티 스레드 소비를 제공하므로써 하나 또는 여러개의 kafkaMessageListenerContainer를 위임받아 사용
      ```java
      // ConcurrentMessageListenerContainer 사용
      @Bean
      public ConcurrentKafkaListenerContainerFactory<String, String> concurrentKafkaListenerContainerFactory() {
          ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
          factory.setConcurrency(3);
          factory.setConsumerFactory(new DefaultKafkaConsumerFactory<String, String>(getConfig()));
          factory.getContainerProperties().setPollTimeout(500L);
          factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);
          return factory;
      }
      ```
      - concurrency 를 세팅하여 N개의 KafkaMessageListenerContainer 인스턴스 생성, 병렬처리가 가능하다.

- Offset Commit
  - enable.auto.commit 이 false인 경우 여러 AckMode 설정을 제공하며 기본은 AckMode.BATCH 를 사용한다.
    |설정|설명|
    |---|---|
    |RECORD|레코드 처리 후 리스너가 리턴할 때 오프셋 커밋|
    |BATCH|poll() 메서드를 통해 반환된 전체 레코드 처리 후 오프셋 커밋|
    |TIME|마지만 커밋 이후 ackTime이 경과되지 않은 경우에 poll()에서 반환된 모든 레코드가 처리되면 오프셋 커밋|
    |COUNT|마지막 커밋 이후 ackCount 레코드가 수신된 경우 poll()에서 반환된 모든 레코드가 처리되면 오프셋 커밋|
    |COUNT_TIME|TIME, COUNT와 유사하지만 두 조건 중 하나가 true면 커밋|
    |MANUAL|Message Listener는 Acknowlegment에서 acknowledge()를 호출해야 한다. 이후에는 BATCH와 동일|
    |MANUAL_IMMEDIATE|Acknowledgment.acknowledge() 호출되면 즉시 오프셋 커밋|
    - MANUAL, MANUAL_IMMEDIATE를 사용하기 위해서는 AcknowledgeMessageListener, BatchAcknowledgingMessageListener 중에 선택해야 한다.

- 

#### @KafkaListener 설정

- @KafkaListener 를 사용하기 위해서는 Configuration 설정을 해주어야 한다.
  ```java
  
  ```

#### 출처

- Spring Docs[https://docs.spring.io/spring-kafka/reference/kafka/receiving-messages.html]
