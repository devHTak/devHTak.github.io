---
layout: post
title: Mongodb - index, shading, replica
summary: JUnit 사용법
author: devhtak
date: '2021-10-11 21:41:00 +0900'
category: No SQL
---

#### Mongodb index

- index
  - index는 디비의 검색을 빠르게 하기 위해 미리 데이터의 순서를 정리해두는 과정
  - Mongodb는 고정된 스키마는 없지만 원하는 데이터 필드를 인덱스로 지정하여 검색 결과를 빠르게 하는 것이 가능
  - NOSQL 에서도 index를 잘 설계해야 최대의 효율이 가능
  - Mongodb는 B-Tree 구조로 index를 구현
  - 고유 index, 희소 index, 다중 키 index, 복합 index, 단일 index 지원

- index 개념
  - index는 도큐먼트를 쿼리해오기 위한 작업량을 줄인다
    - 적당한 index가 없으면 질의 조건을 만족할 때까지 모든 도큐먼트를 순차적으로 스캔
  - 한 쿼리당 하나의 index만 유효
  - 두 개의 index가 필요하다면 복합 index를 사용
    - a, b 필드로 구성된 복합 index를 가지고 있다면 a에 대해 단일 index는 제거해도 됨
    - 복합 index에서 키의 순서는 매우 중요
  - _id는 기본적으로 생성되는 index로 도큐먼트를 가르키는 유일한 키값으로 사용
    - 도큐먼트에 빠르게 접근하기 위해서 각 _id는 index로 관리
    
- 효율
  - 쿼리 성능 향상을 위해 무한히 index 를 추가하는 것은 불가능
  - 모든 index에는 결국 유지비가 소요됨
  - 어떤 데이터가 도큐먼트에 추가되거나 수정될 때마다 그 컬렉션에 대해 생성된 index도 그 새로운 도큐먼트를 포함시키도록 수정되어야 함
  - 최악의 경우에는 결국 데이터를 다시 정렬해야 하는 상황 발생
  - index는 읽기 위주의 어플리케이션에서 유용
  - 읽기보다 쓰기 작업이 많다면 어느 정도 index를 포기하거나 index를 위한 컬렉션을 따로 운영해야 함
  - Mongodb는 기동시 모든 데이터 파일을 메모리에 매핑함
  - 모든 도큐먼트, 컬렉션, 인덱스를 포함하는 모든 데이터 파일이 페이지(page)라고 부르는 4kb정도의 청크 단위로 운영체제에 의해 램에 적재
  - 램의 모든 데이터를 수용만 할 수 있다면 디스크 액세스 횟수 최소화 가능
  - 모든 데이터를 수용하지 못하면 페이지 폴트가 자주 발생하게 되고 운영체제가 디스크를 빈번하게 액세스하게 됨으로 인해 읽기/쓰기 연산 지연 발생
  - 스레싱(thrasing): 모든 데이터를 디스크에서 액세스해야 하는 경우 굉장한 성능 저하를 초래
  - 최소한의 인덱스가 메모리에 위치 할 수 있도록 최소화될 필요가 있음
  - 복합인덱스는 더 많은 공간을 필요로 함을 고려해야 함
  
- B-Tree
  
  ![image](https://user-images.githubusercontent.com/42403023/136956370-797d993a-0986-4fd1-aace-265617a7e655.png)

  - 트리구조와 유사한 데이터 구조
  - 각 노드는 여러 개의 키를 갖는 것이 가능
  - Mongodb에서 사용하는 B-Tree는 새 노드에 대해 8192바이트를 할당함
    - 각 노드가 수백개의 키를 가질 수 있다.
  - 인덱스 키의 평균 크기에 따라 달라질 수도 있는데, 보통 키의 평균적인 크기는 30바이트 안팎임
  - 특징
    - 정확한 일치, 범위 조건, 정렬, 프리픽스 일치 등 다양한 쿼리를 용이하게 처리하도록 도와준다
    - 키가 추가되거나 삭제되더라도 밸런스 유지에 좋다
    
#### Mongodb index 활용

- index 확인
  ```
  > db.scores.getIndexes();
  [ { "v" : 2, "key" : { "_id" : 1 }, "name" : "_id_" } ]
  ```
  
- index 생성
  ```
  > db.scores.createIndex({"name": 1})
  {
    "numIndexesBefore" : 1,
    "numIndexesAfter" : 2,
    "createdCollectionAutomatically" : false,
    "ok" : 1
  }
  > db.scores.getIndexes();
  [
    {
      "v" : 2,
      "key" : {
        "_id" : 1
      },
      "name" : "_id_"
    },
    {
      "v" : 2,
      "key" : {
        "name" : 1
      },
      "name" : "name_1"
    }
  ]
  
  # db.scores.createIndex({"name": 1}, {unique: true})
  # db.scores.createIndex({"name": 1}, {unique: true, dropDups: true})
  ```
  - 오름차순이면 1, 내림차순이면 -1을 지정
  - unique를 사용하여 고유 인덱스를 생성할 수 있다.
    - unique 속성을 지정해서 중복 데이터가 저장되지 못하도록 하면, 데이터가 저장과 검색속도를 늘리는데 도움이 된다
  - dropDups(중복 데이터 삭제): 특정 필드를 Unique를 하게 했을 때 기존에 이미 중복된 데이터가 있을 경우에 대한 정책이 필요. dropDups를 하면 기존에 중복 데이터를 삭제하고 인덱스 저장이 가능

- index 삭제
  ```
  > db.scores.dropIndex({"name": 1})
  > db.scores.dropIndex()
  ```
  - 지정된 인덱스만 삭제가 가능하고, 모든 인덱스 삭제도 가능하다( \_id는 제외 ) 

#### 샤딩

- 목적
  - 데이터 분산 저장
    - 단 한대의 서버에 빅데이터를 저장하는 것을 불가능
    - 서비스의 성능 저하 유발: 초당 발생하는 엄청난 양의 Insert 동작시 Write Scaling 문제 발생
    - 디스크를 사용하는 하드웨어 한계성
    - 데이터를 분산하여 순차적으로 저장한다면 한 대 이상에서 트래픽을 감당하기 때문에 부하를 분산하는 효과가 있다.

  - 백업과 복구 전략
    - 데이터 분산이라는 샤딩의 가장 대표적인 기능을 통해 얻는 효과
    - 시스템의 성능 향상
    - 데이터 유실 가능성으로부터 보호
    - 서버의 데이터가 유실된다면 그 데이터 양은 상상을 초월할 것이고 시스템 복구에 엄청난 시간과 비용 소요
    - 미리 데이터를 분산하여 저장해둔다면 리스크로부터 보호받고 효과적인 시스템 운영이 가능해진다.

  - 빠른 성능
    - 여러 대의 독립된 프로세스가 병렬로 작업을 동시에 수행하기 때문에 이상적으로 빠른 처리 성능을 보장받는다.

- 샤딩 시스템 구조

  ![image](https://user-images.githubusercontent.com/42403023/136961245-ac99aba9-1b8e-41bc-aec4-99760c7153d4.png)
  
  - 특징
    - 샤딩 시스템은 분산처리를 통한 효율 향상
      - 가능한 성능 보장을 위해 3대 이상의 서버를 샤드로 활용하는 것을 추천
      - 최소 2대만 있으면 샤드 서버 구축 가능
    - 기존에 한대의 서버보다 메모리를 20~30% 추가로 사용하게 된다
      - 샤드 시스템 구축 시 사용하는 라우팅 서버인 mongos, OpLog, Balancer 프로세스가 추가로 메모리를 사용
      - 기존에 싱글서버보다 20~30% 정도 추가 메모리 준비가 필요하다

- Config 서버 개요
  - Config 서버는 샤드 시스템에 대한 메타 데이터 저장/관리 역할
  - 샤드 서버의 인덱스 정보를 빠르게 검색 가능케 함
  - 샤드 서버와 별도의 서버에 구축이 기본
  - 장애 발생에 대비하여 최소 3대 이상 사용(최소 1대만으로 운영 가능)
  - 샤드 서버에 비해 저사양 서버 사용 가능

- Mongos 서버 특징
  - 하나 이상의 프로세스 사용
  - Config 서버의 Meta-data를 캐시한다.
  - 빅데이터를 샤드 서버로 분산해주는 프로세스
  ```
  - Config 서버는 각 샤드 서버에 어떤 데이터들일 어떤 식으로 분산 저장되어 있는지에 대한 Meta 데이터가 저장
  - mongos 서버를 통해 데이터를 쓰고 읽는 작업 가능
  - 또한 mongos 는 각 서버에서 어떤 일을 하는지 개발자가 모르게 해주는 역할을 한다.
  - 지금 샤딩 상태인지 리플리케이션 상태인지 개발자는 알 필요가 없다.
  ```
  
- Shading System layer
  - 중개자 계층: 샤딩 시스템의 가장 핵심적인 부분, 메타정보 저장 및 application과 data간에 적절한 질의 및 결과를 반환한다

- Shard Key
  - 샤딩 시스템을 구축할 때 가장 중요
  - 여러 개의 Shard 서버로 분할될 기준 필드를 가리키며, partition, load balancing에 기준이 된다.
  - shard key는 cardinality를 보고 적절한 선택이 필요하다. 
    - 데이터 분포가 넓으면 low cardinality라고 표현하고, 분포가 높으면 high cardinality라고 부른다
  - chunk migration의 횟수와 빈도 결정
    - 하나의 서버에 저장되는 데이터들을 여러 개의 논리적 구조로 분할 저장하다가 일정한 양에 도달했을 때 2~3번째 서버로 데이터를 분할하여 저장하며, 분할 저장단위가 chunk이다.
    - chunk의 기본 단위는 64MB 단위로 분할되며, 필요시 64MB 이상의 Chunk 크기를 갖는 것도 가능
    - 기본설정 단위보다 빈번하게 Chunk Migration이 발생한다면 Chunk 크기를 더우 크게 설정해야 한다
    - 하나의 서버에만 데이터가 집중되고 골고루 분산되지 않으면 Chunk 크기를 더 작게 설정해야 한다

#### 출처

- B-Tree: https://ichi.pro/ko/mongodb-indegseu-simcheung-bunseog-indegseu-ihae-171312403020454
- shading: https://www.infoq.com/news/2010/08/MongoDB-1.6
  
  
